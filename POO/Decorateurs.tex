\section{Décorateurs}
\index{décorateur}
Les décorateurs sont des fonctions ou des classes qui permettent de modifier le comportement d'une autre fonction (ou classe). Les décorateurs sont utiles lorsque l'on souhaite qu'un certain nombre de fonctions effectuent des tâches communes comme par exemple donner leur temps d'exécution. On appelle un décorateur de la manière suivante.

\begin{minted}{python3}
@decorateur
def fonction():
    pass
\end{minted}

Le code précédent a le même comportement que le code suivant:

\begin{minted}{python3}
def fonction():
    pass

fonction = decorateur(fonction)
\end{minted}

Ainsi, \mintinline{python3}{fonction} devient l'objet retournée par \mintinline{python3}{decorateur(fonction)}. Le décorateur doit donc retourner un objet que l'on peut appeler en écrivant \mintinline{python3}{objet()} (avec d'éventuels arguments), on appelle ce type d'objet un \og appelable \fg{}\index{appelable}, une généralisation des fonctions. Le décorateur est lui même un appelable. Si on le définit comme une classe, on doit définir la méthode \mintinline{python3}{__call__()} qui permet de rendre ses instances appelables.

\paragraph{Plus d'informations} \href{https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators/1594484#1594484}{Stack Overflow}

\subsection{En tant que classe}
Une façon d'implémenter un décorateur est d'utiliser les classes. La fonction décorée deviendra alors une instance de la classe de ce décorateur. Il faut obligatoirement définir la méthode \mintinline{python3}{__call__()} pour pouvoir rendre cette instance appelable.

\paragraph{Exemple} On considère ici un décorateur qui compte le nombre d'appels de la fonction décorée.
\begin{minted}{python3}
class Compteur:
    def __init__(self, f):
        self.call = 0
        self.f = f

    def __call__(self, *args, **kwargs):
        self.call += 1
        print("La fonction {} a été appelée {} fois.".format(self.f.__name__, self.call))
        return self.f(*args, **kwargs)
\end{minted}


\subsection{En tant que fonction}
Comme un décorateur est un objet appelable qui n'a d'autre utilité que d'être appelé, il est aussi logique de le définir en tant que fonction.

\paragraph{Exemple} Même décorateur que précédemment mais en l'implémentant en tant que fonction.
\begin{minted}{python3}
def compteur(f):
    def wrapper(*args, **kwargs):
        wrapper.call += 1
        print("La fonction {} a été appelée {} fois.".format(f.__name__, wrapper.call))
        return f(*args, **kwargs)
    wrapper.call = 0
    return wrapper
\end{minted}

\paragraph{Remarques} On voit dans cet exemple que l'on peut définir des fonctions dans les définitions de fonctions. La mention \mintinline{python3}{*args} fait référence à tous les arguments non nommés que l'on a entrés (c'est un tuple, par exemple \mintinline{python3}{(arg1, arg2)}). La mention \mintinline{python3}{**kwargs} fait référence aux arguments nommés (c'est un dictionnaire). Ainsi on est sûr de récupérer tous les arguments.\bigskip

Dans cet exemple, on assigne à \mintinline{python3}{wrapper} un attribut de fonction (on peut le faire, puisqu'une fonction est un objet -- de la classe \mintinline{python3}{function}). On le définit après avoir défini cette fonction.

\subsection{Décorateurs à paramètres}
On peut faire en sorte que le décorateur prenne un ou plusieurs paramètres. Dans ce cas, il faut définir le décorateur à l'intérieur d'une clôture qui prend en argument ces différents paramètres.

\paragraph{Exemple} On veut retourner une erreur quand la fonction retourne une valeur trop élevée.
\begin{minted}{python3}
def depasse_max(max):
    def deco(f):
        def wrapper(*args, **kwargs):
            n = f(*args, **kwargs)
            if n > max:
                print("Maximum {} dépassé.".format(max))
                return
            return n
        return wrapper
    return deco
\end{minted}

Ces deux syntaxes sont équivalentes:

\begin{minted}{python3}
# Syntaxe 1
@depasse_max(10)
def demande_nombre():
    n = int(input("Entrer un nombre : "))
    return n

# Syntaxe 2
def demande_nombre():
    n = int(input("Entrer un nombre : "))
    return n

demande_nombre = depasse_max(10)(demande_nombre)
\end{minted}

Cela permet de faire

\begin{minted}{pycon}
>>> demande_nombre()
Entrer un nombre : 11
Maximum 10 dépassé.
\end{minted}