\documentclass[a4paper, 10pt]{article}
\usepackage[french]{babel}
\usepackage[left = 3 cm, right = 2 cm, top = 2 cm, bottom = 2 cm]{geometry}
\usepackage{makeidx}
\makeindex
\usepackage{fontspec}
\usepackage[langlinenos, draft=false]{minted}
%% Décommenter si Windows
\setmainfont{Linux Libertine}
\setsansfont{Linux Biolinum}
%% Décommenter si sur Linux
% \setmainfont{Linux Libertine O}
% \setsansfont{Linux Biolinum O}
\setmonofont{Consolas}
\setminted{fontsize=\footnotesize, frame=single}
\setmintedinline{fontsize=\footnotesize}
\usepackage{xcolor}
\usepackage{color}
%\rmfamily % To load Latin Modern Roman and enable the following NFSS declarations.
% Declare that Latin Modern Roman (lmr) should take
% its bold (b) and bold extended (bx) weight, and small capital (sc) shape,
% from the corresponding Computer Modern Roman (cmr) font, for the T1 font encoding.
%\DeclareFontShape{T1}{lmr}{b}{sc}{<->ssub*cmr/bx/sc}{}
%\DeclareFontShape{T1}{lmr}{bx}{sc}{<->ssub*cmr/bx/sc}{}
\usepackage[colorlinks=true]{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=blue,colorlinks=true}
\usepackage{sectsty}
\allsectionsfont{\bfseries\sffamily}
\usepackage{caption}
\usepackage{graphicx}
\setlength\parindent{0pt}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{myblue}{rgb}{0,0,1}
% \usepackage{titlesec}
\usepackage{titletoc}
\setcounter{tocdepth}{3}
\reversemarginpar
\setlength{\marginparwidth}{2.4cm}
\usepackage{enumitem}

\titlecontents
	{section}
	[0em]
	{\addvspace{0.5em}}
	{{\thecontentslabel.\ }}
	{}
	{\hfill\contentspage}
	[\addvspace{0pt}]

\titlecontents
	{subsection}
	[1em]
	{\addvspace{0.25em}}
	{\thecontentslabel.\ }
	{}
	{\hfill\contentspage}
    [\addvspace{0pt}]

\titlecontents
	{subsubsection}
	[2em]
	{\addvspace{0.25em}}
	{\thecontentslabel.\ }
	{}
	{\hfill\contentspage}
    [\addvspace{0pt}]

% Réinitialise les numéros de sections à chaque partie
\makeatletter
\@addtoreset{section}{part}
\makeatother 

\begin{document}

\definecolor{fondsolarized}{RGB}{253,246,227}
\definecolor{blanc}{RGB}{255, 255, 255}

\begin{center}
        {\Huge{\sc\bfseries{Mémo Python}}}\\[20pt]
        \includegraphics[scale=0.07]{python.png}
        \vspace{20pt}
\end{center}

\tableofcontents

\hypersetup{linkcolor=blue}

\newpage
\section*{Avant de commencer (sauf pour les impatients)}

Un \marginpar{\href{http://python.pycolore.fr}{Permalien}} mémo d'une cinquantaine de page? Oui ça parait long mais Ctrl-F (ou plutôt la fonction Rechercher) est là pour vous aider à cibler! Il y a un aussi index à la fin plus ou moins à jour. Je rédige ce pdf au fur et à mesure que j'en apprends sur Python... Bonne lecture!\bigskip

Ne sont pas reprises les opérations \og basiques \fg{} (boucles, manipulation des listes). On s'intéresse directement à la programmation orientée objet. Ensuite sont détaillés quelques fonctionnalités apportées par des modules. Une partie sur Django est particulièrement plus développée.\bigskip

Sauf exception, on considère qu'on travaille sur une distribution GNU/Linux (par exemple: Linux Mint, Fedora, Solus, Debian, Arch Linux).\bigskip

De nombreux liens sont disponibles. De manière générale:
\begin{enumerate}
    \item Des liens vers les documentations sont fournis.
    \item Des liens plus précis sont fournis en cliquant sur les termes dans la marge. < en cours! (càd incomplet)
    \item Pour le reste, tout ce qui est en bleu = lien (sauf dans les cadres de code).
\end{enumerate}\bigskip

Ce document est écrit au format TeX puis compilé avec XeLaTeX (et minted pour les sections de code). Il est disponible au téléchargement (pour mettre le document à jour) en cliquant sur ce lien: \href{https://python.pycolore.fr}{python.pycolore.fr}.

\paragraph{Nota Bene} Ce document est encore incomplet, des sections sont susceptibles d'être vides.

\paragraph{Notation} Toutes les fonctions sont notées avec des parenthèses : \mintinline{python3}{function()}.
\bigskip

Auteur : Guillaume Fayard.

\newpage
\part{Programmation orientée objet en Python}


% \section{Variables}
% \index{variable}

\section{Classes}
\index{classe}

Les classes permettent des créer des objets\index{objet} appelés instances\index{instance} qui partagent des caractéristiques communes. Une classe est en fait un gabarit qui nous permet de créer un certain type d'objets.

\paragraph{Plus d'informations} \href{https://openclassrooms.com/courses/apprenez-a-programmer-en-python/premiere-approche-des-classes}{Introduction OpenClassrooms}, \href{https://docs.python.org/fr/3/tutorial/classes.html}{Documentation Python 3}, \href{https://fr.wikibooks.org/wiki/Programmation_Python/Classes#Définition_d'une_classe_élé mentaire}{Wikilivres}

\subsection{Structure d'une classe}
Les objets d'une classe partagent des caractéristiques communes à la classe:
\begin{enumerate}
    \item des attributs\index{attribut}, des variables propres à aux instances;
    \item des méthodes, des fonctions propres aux instances et qui agissent par exemple sur leurs attributs.
\end{enumerate}


\subsubsection{Définition d'une classe}
Pour définir une classe, la syntaxe est la suivante:
\begin{minted}{python3}
class MaClasse:
    pass
\end{minted}

Lorsqu'on lance l'exécution d'un module Python, l'interpréteur exécute le contenu du corps de toutes les classes qu'il rencontre pour la première fois. Ainsi si l'on exécute :

\begin{minted}{python3}
class Foo:
    print('bar')
\end{minted}

La console affichera \mintinline{python3}{bar}. Pour créer une instance de classe, il faut appeler la classe. Appeler une classe revient à appeler son \hyperref[constructeur]{constructeur}, composé d'un créateur d'objet et d'un initialiseur. En reprenant la classe \mintinline{python3}{Foo}:

\begin{minted}{pycon}
>>> Foo
<class '__main__.Foo'>
>>> Foo()
<__main__.Foo object at 0x7f193dd99630>
\end{minted}

\subsubsection{Initialiseur}
\index{initialiseur}\index{\_\_init\_\_()}

L'initialiseur est une méthode spéciale appelée \mintinline{python3}{__init__()}, il prend en argument l'instance sur laquelle il est appliqué et tous les paramètres nécessaires à l'initialisation de l'instance. Par convention le premier paramètre, l'instance, est nommé \mintinline{python3}{self}.

\begin{minted}{python3}
class MaClasse:

    CONSTANTE = "Constante"

    def __init__(self, att1, att2):
        """Initialiseur"""
        self.attribut_1 = att1
        self.attribut_2 = att2
        self.attribut_3 = type(self).CONSTANTE
\end{minted}

Ici, les deux premiers attributs sont personnalisables lors de la création des objets alors que le dernier est commun à tous. \mintinline{python3}{MaClasse.CONSTANTE} est une variable de classe\index{variable de classe}. Pour créer un objet on écrit simplement:

\begin{minted}{python3}
objet = MaClasse(att1, att2)
\end{minted}

Les informations concernant les attributs d'une instance sont stockées dans le dictionnaire de l'instance, un attribut spécial nommé \mintinline{python3}{__dict__}.

\begin{minted}{pycon}
>>> instance = MaClasse("attr1", "attr2")
{'attribut_1': 'attr1', 'attribut_2': 'attr2', 'attribut_3': 'Constante'}
\end{minted}

\subsubsection{Méthodes}
\index{méthode}
Les méthodes se définissent comme des fonctions, elles agissent en général sur les instances de la classe. Elles doivent toujours prendre \mintinline{python3}{self} en argument :
\begin{minted}{python3}
class MaClasse:

    def __init__(self):
         pass

    def methode(self, arg1, arg2):
         pass
\end{minted}

Ensuite on les appelle de la manière suivante:
\begin{minted}{python3}
objet.methode(arg1, arg2)
\end{minted}


\subsection{Héritage}
\index{héritage}

\subsubsection{Principe}

L'héritage est un moyen de créer des classes dérivées (classes filles) d'une classe de base (classe mère). Une classe fille hérite de toutes les méthodes et variables de sa classe mère. Pour créer une classe fille, on utilise la syntaxe suivante.

\begin{minted}{python3}
class Mere:
    pass

class Fille(Mere):
    pass
\end{minted}

Il est possible d'écraser une méthode héritée en la redéfinissant dans la classe fille. Si on veut accéder à une méthode héritée alors qu'on l'a redéfinie dans la classe fille, on utilise la fonction \mintinline{python3}{super()} qui permet d'appeler la méthode de la classe mère de la classe présente (sans l'argument self).

\paragraph{Exemple}
\begin{minted}{python3}
class Meuble:
    def __init__(self, couleur, materiau):
        self.couleur = couleur
        self.materiau = materiau

class Bibliotheque(Meuble):
    def __init__(self, couleur, materiau, n):
        super().__init__(couleur, materiau)
        self.nb_livres = n
\end{minted}
On peut utiliser deux fonctions pour vérifier l'héritage: \mintinline{python3}{isinstance} renvoie \mintinline{python3}{True} si l'objet est une instance de la classe ou de ses classes filles ; \mintinline{python3}{issubclass} permet de voir si une classe est fille d'une autre.

\begin{minted}{pycon}
>>> bibli = Bibliotheque('blanc', 'vert', 150)
>>> bibli.__dict__
{'couleur': 'blanc', 'materiau': 'vert', 'nb_livres': 150}
>>> isinstance(bibli, Meuble)
True
>>> isinstance(bibli, Bibliotheque)
True
>>> issubclass(Bibliotheque, Meuble)
True
>>> issubclass(Meuble, Bibliotheque)
False
>>> isinstance(bibli, int)
False
>>> isinstance(bibli, object)
True
\end{minted}

\paragraph{Plus d'informations} \href{https://openclassrooms.com/courses/apprenez-a-programmer-en-python/l-heritage-9}{OpenClassrooms}, \href{https://docs.python.org/fr/3/tutorial/classes.html?highlight=héritage#inheritance}{Documentation Python 3}, \href{https://www.programiz.com/python-programming/inheritance}{Programiz}


\subsubsection{Ordre de résolution de méthode}

\subsubsection{Classe mère \mintinline{python3}{object}}
On a dit précédemment que le constructeur était composé d'un initialiseur et d'un créateur d'instance ; cependant l'exemple ne définissait pas de créateur d'instance : c'est parce qu'il est défini dans une classe \mintinline{python3}{object}. Toutes les classes en Python 3 héritent implicitement de cette classe. Elle définit de nombreuses méthodes, notamment les méthodes dites spéciales, que l'on peut surcharger pour les personnaliser.

\begin{minted}{pycon}
>>> class Foo:
...    pass
>>> issubclass(Foo, object)
True
>>> object
<class 'object'>
>>> help(object)
Help on class object in module builtins:

class object
 |  The most base type

>>> class Foo:
...    pass
...
>>> issubclass(Foo, object)
True
\end{minted}

\subsection{Propriétés}
\label{sec:proprietes}\index{propriété}\index{accesseur}\index{mutateur}\index{destructeur}
 Les propriétés représentent en Python le principe d'encapsulation. Elles sont utiles si on souhaite contrôler l'accès à un attribut ou si on veut que le changement d'une valeur d'un attribut engendre des modifications sur d'autres attributs. Les propriétés sont un cas particulier des descripteurs.\bigskip

On crée les propriétés en utilisant des décorateurs. Elles contiennent un accesseur, un mutateur, un destructeur et une aide (docstring de l'accesseur).\bigskip

Les propriétés sont aussi un moyen de simuler des attributs privés: pour simuler un attribut privé, on précède son nom d'un souligné. Ainsi, on appelle cet attribut sans le souligné dans le code grâce aux propriétés. Par convention, on n'agit pas sur les attributs qui commencent par un souligné en Python.

\paragraph{Exemple}~
\begin{minted}{python3}
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
        self._fahrenheit = self._celsius * 1.8 + 32

    @property
    def celsius(self):
        """Propriété 'celsius'."""
        return self._celsius

    @celsius.setter
    def celsius(self, valeur):
        self._celsius = valeur
        self._fahrenheit = valeur * 1.8 + 32

    @celsius.deleter
    def celsius(self):
        del self._celsius
    
    @property
    def fahrenheit(self):
        """Propriété 'fahrenheit'."""
        return self._fahrenheit
    
    @fahrenheit.setter
    def fahrenheit(self, valeur):
        self._fahrenheit = valeur
        self._celsius = (valeur - 32) / 1.8

    @fahrenheit.deleter
    def fahrenheit(self):
        del self._fahrenheit
\end{minted}

On utilise la propriété de la manière suivante:
\begin{minted}{pycon}
>>> temp = Temperature(20)
>>> temp.fahrenheit
68.0
>>> temp.fahrenheit = 69
>>> temp.celsius
20.555555555555554
>>> del temp.fahrenheit
>>> temp.fahrenheit
Traceback (most recent call last):
...
AttributeError: 'Temperature' object has no attribute '_fahrenheit'
\end{minted}

\paragraph{Plus d'informations}\href{https://docs.python.org/fr/3/library/functions.html?highlight=property#property}{Documentation Python 3}, \href{https://stackoverflow.com/questions/15750522/class-properties-and-setattr/15751159#15751159}{Priorités entre propriété et méthodes spéciales}

\subsection{Méthodes statiques et méthodes de classes}
\subsubsection{Méthode statique}
\index{méthode statique}\label{sec:staticmethod}
Les méthodes que l'on a vues jusqu'à maintenant agissent sur les instances des classes : elles prennent toujours en premier argument le mot clé \mintinline{python3}{self} qui renvoie à l'instance elle même. Lorsque l'on appelle une telle méthode sur une instance comme ceci:
\mint{python}|instance.methode(*args, **kwargs)|
Python exécute en fait: \mint{python}|type(instance).methode(instance, *args, **kwargs)|
Évaluer \mintinline{python3}{type()} sur un objet renvoie sa classe.

En fait, ces deux objets sont différents. \mintinline{python3}{Classe.methode} est une simple fonction, alors que \mintinline{python3}{instance.methode} est une méthode évaluée sur l'instance (méthode liée, en anglais \og bound method \fg{}\index{bound method}), c'est-à-dire que l'instance est mise en premier argument. On considère cet exemple:

\paragraph{Exemple}
\begin{minted}{python3}
class Maths:

    @staticmethod
    def addition(x, y):
        return x + y

    @staticmethod
    def multiplication(x, y):
        return x * y

    @staticmethod
    def division(x, y):
        return x / y
\end{minted}
On choisit ici de grouper trois fonctions car elles sont logiquement liées. Elles n'influent pas les instances donc elles ne prennent pas \mintinline{python3}{self} en argument. Si l'on appelle ces méthodes sur une instance, une exception sera levée car Python entrera automatiquement l'argument \mintinline{python3}{self} (donc en tout trois arguments) alors que les méthodes n'en prennent que deux. Pour remédier à cela, on les décore avec \mintinline{python3}{@staticmethod}. On peut maintenant les appeler indifféremment sur la classe ou sur des instances. On fait rarement ce genre de classe en Python, mais il peut arriver d'avoir des méthodes statiques dans une classe.

\subsubsection{Méthode de classe}
\index{méthode de classe}\label{sec:classmethod}
Lorsque l'on veut manipuler des variables de classe et non des attributs d'instances, on crée des méthodes de classe. Celles-ci prennent la classe en premier paramètre, par convention on le note \mintinline{python3}{cls}; elles ne prennent logiquement pas \mintinline{python3}{self} comme paramètre. Cette méthode est donc évaluée sur la classe. Sans autre modification, on ne peut peut appeler cette méthode que sur les instances car Python attend l'argument \mintinline{python3}{cls}. Pour pouvoir appeler cette méthode sur la classe (logique car c'est une méthode de classe), on la décore avec \mintinline{python3}{@classmethod}.

\subsubsection{Cas de l'héritage}
En résumé:
\begin{enumerate}
        \item Les méthodes statiques sont des fonctions reliées à des classes, mais qui n'agissent pas sur celles-ci.
        \item Les méthodes de classe sont des fonctions qui prennent la classe en paramètre.
\end{enumerate}

Une classe qui hérite d'une classe mère hérite de toutes les méthodes de celle-ci. Les méthodes statiques restent donc inchangées, tandis que les méthodes de classe s'adaptent à la nouvelle classe, car elles la prennent en premier argument.

\paragraph{Exemple} Un exemple d'utilisation de méthodes statiques et de classe sont la création de constructeurs alternatifs. On s'aperçoit de la différence des deux notions.
\begin{minted}{python3}
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    @staticmethod
    def par_date_de_naissance(nom, date):
        return Personne(nom, 2018-date)

    @classmethod
    def par_date_de_naissance2(cls, nom, date):
        return cls(nom, 2018-date)

class Homme(Personne):
    sexe = 'homme'
\end{minted}
\begin{minted}{pycon}
>>> homme1 = Homme.par_date_de_naissance('Jean', 1997)
>>> homme2 = Homme.par_date_de_naissance2('Jean', 1997)
>>> type(homme1)
<class '__main__.Personne'>
>>> type(homme2)
<class '__main__.Homme'>
\end{minted}

Pour avoir \mintinline{python3}{homme1} de type \mintinline{python3}{Homme}, il faut redéfinir la méthode statique dans la classe fille.

\paragraph{Plus d'informations} \href{https://www.programiz.com/python-programming/methods/built-in/staticmethod}{Méthode statique sur Programiz}, \href{https://www.programiz.com/python-programming/methods/built-in/classmethod}{Méthode de classe sur Programiz}, \href{https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python/1669524#1669524}{StackOverflow}



\section{Méthodes spéciales}
\index{méthode spéciale}
Python est un langage avec une syntaxe de haut niveau, c'est-à-dire facilement compréhensible par l'utilisateur humain. Derrière cette syntaxe se cachent des méthodes appelées méthodes spéciales. On les reconnaît par la présence de soulignés qui encadrent leur nom, c'est le cas de \mintinline{python3}{__new__()} et \mintinline{python3}{__init__()}.

\paragraph{Exemples}
\begin{minted}{python3}
## Syntaxe de haut niveau   ## Méthode spéciale correspondante
# Listes
L = [1, 2, 3]
2 in L                      # L.__contains__(2)
len(L)                      # L.__len__()

# Opérations
objet1 + objet2             # objet1.__add__(objet2)
objet1 == objet2            # objet1.__eq__(objet2)

# Conversion en str ou affichage
print(objet)                # objet.__str__()
str(objet)                  # objet.__str__()

# Appel d'une fonction
fonction()                  # fonction.__call__() <- intéressant celui-là !
\end{minted}

\paragraph{Plus d'informations} \href{https://docs.python.org/3/reference/datamodel.html#specialnames}{Documentation Python 3}, \href{https://openclassrooms.com/courses/apprenez-a-programmer-en-python/les-methodes-speciales-1}{OpenClassroom}


\subsection{Création, initialisation et finalisation}
\begin{description}
    \item[\mintinline{python3}{object.__new__(cls[, *args, **kwargs])}]~

    Créateur de l'instance. C'est une méthode statique qui prend en premier paramètre obligatoire la classe de l'instance à créer. Les arguments suivants sont ceux passés à l'initialiseur. Cette méthode doit renvoyer une nouvelle instance. L'initialiseur est alors appelé. En général, on n'implémente pas cette méthode, sauf dans certains cas particuliers.\bigskip

    Cette méthode statique est un cas particulier qui ne nécessite pas de décorateur \mintinline{python3}{@staticmethod}.

    \item[\mintinline{python3}{object.__init__(self[, *args, **kwargs])}]~

    Initialiseur de l'instance. C'est ici qu'on initialise les attributs de l'instance.
\end{description}

Ces deux méthodes forment le constructeur\label{constructeur} de l'instance, elles sont appelées lorsqu'on appelle la classe pour construire un objet. Si on surcharge ces méthodes, il ne faut pas oublier d'appeler les méthodes héritées grâce à \mintinline{python3}{super()}. Dans le cas où la classe hérite uniquement d'\mintinline{python3}{object}, il n'y a pas besoin d'appeler \mintinline{python3}{super().__init__()} car les instances d'\mintinline{python3}{object} n'ont aucun attribut (donc il n'y a pas d'initialisation).

\paragraph{Exemple} On veut définir une classe \og singleton \fg{} qui ne peut créer qu'une instance.

\begin{minted}{python3}
class Singleton:
    """Classe qui ne peut instancier qu'une fois."""

    instance = None

    def __new__(cls, *args, **kwargs):
        if not cls.instance:
            cls.instance = super().__new__(cls)
            return cls.instance
        else:
            raise TypeError(f"Cette classe singleton possède déjà une instance : {cls.instance}")

    def __del__(self):
        Singleton.instance = None

    def __init__(self, *args, **kwargs):
        pass
\end{minted}

\begin{description}
    \item[\mintinline{python3}{object.__del__(self)}]~

    Finaliseur de l'instance. Cette méthode est appelée lorsqu'un objet est sur le point d'être détruit, mais n'est pas responsable de sa destruction. Lorsqu'on hérite uniquement d'\mintinline{python3}{object}, il n'est pas nécessaire d'appeler \mintinline{python3}{super().__del__()} car elle ne fait rien. La syntaxe \mint{python}|del obj| décrémente le nombre de références de \mintinline{python3}{obj}. Si celui-ci atteint zéro, alors \mintinline{python3}{obj.__del__()} est appelée.
\end{description}

\subsection{Représentation et chaîne de caractères d'un objet}
Si on crée une instance de la classe \mintinline{python3}{Singleton} précédente et qu'on demande sa représentation dans l'interpréteur, il nous renvoie quelque chose de pas très explicite:

\begin{minted}{pycon}
>>> inst = Singleton()
>>> inst
<__main__.Singleton object at 0x000002B07DB73898>
\end{minted}

On doit donc définir une méthode de représentation.

\begin{description}
    \item[\mintinline{python3}{object.__repr__(self)}]~

    Appelée par \mintinline{python3}{repr()}, ou bien lorsqu'on demande l'objet dans l'interpréteur. Cette méthode calcule et renvoie une chaîne de caractères compréhensible \og officielle \fg{}, c'est-à-dire qu'elle doit ressembler à une expression Python à partir de laquelle on doit pouvoir recréer un objet de la même valeur. Si ce n'est pas possible, elle devrait renvoyer une description entre chevrons \mintinline{python3}{"<description>"}. 
\end{description}

Parfois, on veut quelque chose de plus joli destiné à un véritable affichage (quand on appelle \mintinline{python3}{print()}). On peut vouloir aussi avoir la capacité de convertir un objet en une chaîne de caractère avec \mintinline{python3}{str()}. On doit alors définir une autre méthode spéciale:

\begin{description}
    \item[\mintinline{python3}{object.__str__(self)}]~

    Appelée par \mintinline{python3}{str()}, \mintinline{python3}{print()} et \mintinline{python3}{format()}. Cette méthode renvoie une chaîne de caractère correspondant à la représentation informelle de l'objet. Si cette méthode n'est pas définie, alors \mintinline{python3}{__repr__()} est utilisée à la place.
\end{description}
\paragraph{Exemple} L'exemple suivant
\begin{minted}{python3}
class MaClasse:
    def __init__(self, attr):
         self.attribut = attr

    def __repr__(self):
        return "MaClasse(attribut={})".format(self.attribut)

    def __str__(self):
        return "Instance de MaClasse ayant comme attribut {}"
              .format(self.attribut)
\end{minted}
permet de faire:
\begin{minted}{pycon}
>>> obj = MaClasse("Exemple")
>>> obj
MaClasse(attribut=Exemple)
>>> print(obj)
Instance de MaClasse ayant comme attribut Exemple.
\end{minted}

\subsection{Accès et modification des attributs}
On a vu précédemment les propriétés qui permettent une sore d'encapsulation des attributs. Lorsqu'on veut accéder à un attribut par la syntaxe \mint{python}|instance.attr| Python appelle en premier une méthode spéciale.

\begin{description}
    \item[\mintinline{python3}{object.__getattribute__(self, name)}]~
    
    Appelée en premier lorsque l'on veut accéder à un attribut par les syntaxes
    \begin{minted}{python3}
instance.attr             # instance.__getattribute__('attr')
getattr(instance, 'attr') # instance.__getattribute__('attr')
    \end{minted} 
    Cette méthode renvoie l'attribut \mintinline{python3}{name} demandé s'il existe et lève une exception \mintinline{python3}{AttributeError} sinon. Dans ce cas, une autre méthode est appelée. Pour éviter une récursivité infinie, cette méthode doit utiliser \mintinline{python3}{__getattribute__()} d'une classe parente (par exemple \mintinline{python3}{super().__getattribute__()}) pour avoir accès aux attributs dont elle a besoin. En particulier, elle doit retourner \mintinline{python3}{super().__getattribute__(self, name)}.

    \item[\mintinline{python3}{object.__getattr__(self, name)}]~

    Appelée si \mintinline{python3}{__getattribute__()} lève une exception \mintinline{python3}{AttributeError}. Par défaut, cette méthode fait la même chose, mais c'est ici que l'on peut calculer des attributs dynamiques: des attributs qui ne sont pas initialisés mais dont on veut pouvoir calculer la valeur.

    \item[\mintinline{python3}{object.__setattr__(self, name, value)}]~

Appelée lorsque l'on assigne une valeur à un attribut: 
    \begin{minted}{python3}
instance.attr = value            # instance.__setattr__('attr', value)
setattr(instance, 'attr', value) # instance.__setattr__('attr', value)
    \end{minted}
    
    Par défaut, le mécanisme est de changer la valeur de clé \mintinline{python3}{'name'} dans le dictionnaire de l'instance. Pour assigner des valeurs à des attributs, cette méthode doit utilise \mintinline{python3}{super().__setattr__()} afin d'éviter une récursivité infinie.

    \item[\mintinline{python3}{object.__delattr__(self, name)}]~

    Appelée lorsque l'on veut détruire un attribut : 
    \begin{minted}{python3}
del instance.attr         # instance.__delattr__('attr')
delattr(instance, 'attr') # instance.__delattr__('attr')
    \end{minted}
    
    Finalise l'attribut avant sa suppression s'il existe et lève une exception \mintinline{python3}{AttributeError} sinon. Cette méthode doit appeler \mintinline{python3}{super().__delattr__()} pour éviter une récursivité infinie lors de l'appel à la suppression de l'attribut.
\end{description}  


\paragraph{Exemple}
\begin{minted}{python3}
class MaClasse:
    def __init__(self)
        self.a = int()

    def __getattribute__(self, attribut):
        print("J'accède à l'attribut {}...".format(attribut))
        return object.__getattribute__(self, attribut)

    def __getattr__(self, attribut):
        print("L'attribut {} est inaccessible !".format(attribut))

    def __setattr__(self, attribut, valeur):
        object.__setattr__(self, attribut, valeur)
        print("L'attribut a été changé !")
        # Il est nécessaire d'appeler la méthode par défaut, car appeler self.__setattr__
        # donnerait une récursivité infinie. En fait, on ne sait à ce stade pas comment
        # Python change concrètement la valeur de l'attribut.
\end{minted}

Cela permet de faire:
\begin{minted}{pycon}
>>> objet = MaClasse()
L'attribut a été changé !
>>> objet.b
L'attribut b est inaccessible !
>>> objet.a
J'accède à l'attribut a...
0
>>> objet.attribut = 1
L'attribut a été changé !
>>> objet.a
J'accède à l'attribut a...
1
\end{minted}

À ce stade, on peut se demander quelle solution choisir pour contrôler les accès aux attributs ou faire des attributs dynamiques: propriétés, descripteurs --- leur généralisation ---, méthodes spéciales ?) La réponse pythonique est: si on peut faire ce que l'on veut facilement, ne pas choisir une solution compliquée inutilement! Une réponse sur StackOverflow (voir \og Plus d'informations \fg{} propose ceci:
\begin{itemize}
    \item La première solution la plus simple: affecter simplement les valeurs aux attributs avec le mécanisme par défaut
    \item Si ce mécanisme est insuffisant, utiliser les propriétés.
    \item Si ce mécanisme est insuffisant, écrire des descripteurs adaptés.
    \item Si ce mécanisme est inadapté, utiliser \mintinline{python3}{__getattr__()}
    \item En dernier recours, utiliser \mintinline{python3}{__getattribute__()}
\end{itemize}

Les propriétés sont particulièrement adaptées pour gérer un petit nombre d'attributs spécifiques; pour changer le comportement de tous les attributs ou presque, c'est \mintinline{python3}{__getattr__()} qui sera plus avantageux. En dernier recours \mintinline{python3}{__getattribute__()} permettra d'agir sur les attributs qui sont vraiment définis, alors que \mintinline{python3}{__getattr__()} permet de simuler la présence d'attributs. Cette dernière fonction a l'inconvénient d'agir sur tous les attributs, donc peut engendrer un comportement indésirable chez quelques attributs si l'on ne fait pas bien attention.

\subsection{Surcharges d'opérateur}
\index{surcharge d'opérateur}
Les surcharges d'opérateur permettent de faire des opérations arithmétiques avec des objets, c'est-à-dire d'indiquer à Python ce qu'il faut faire lorsque l'on exécute \mintinline{python3}{objet1 + objet2}. Ces méthodes prennent en arguments \mintinline{python3}{self} (l'objet 1) et l'objet 2.
\begin{center}
\begin{tabular}{|p{2.5cm}|c|}
        \hline
        \multicolumn{1}{|c|} {\bf Méthode} & {\bf Appel}\\
        \hline
        \mintinline{python3}{__add__()}\index{\_\_add\_\_()} & \mintinline{python3}{objet1 + objet2}\\
        \hline
        \mintinline{python3}{__sub__()}\index{\_\_sub\_\_()} & \mintinline{python3}{objet1 - objet2}\\
        \hline
        \mintinline{python3}{__mul__()}\index{\_\_mul\_\_()} & \mintinline{python3}{objet1 * objet2}\\
        \hline
        \mintinline{python3}{__truediv__()}\index{\_\_truediv\_\_()} & \mintinline{python3}{objet1 / objet2}\\
        \hline
        \mintinline{python3}{__floordiv__()}\index{\_\_floordiv\_\_()} & \mintinline{python3}{objet1 // objet2}\\
        \hline
        \mintinline{python3}{__mod__()}\index{\_\_mod\_\_()} & \mintinline{python3}{objet1 \% objet2}\\
        \hline
\end{tabular}
\end{center}
Les deux objets ne sont pas nécessairement du même type ! Cependant, cette opération n'est pas symétrique : le code \mintinline{python3}{objet + 5} par exemple exécute \mintinline{python3}{objet.__add__(5)}, alors que \mintinline{python3}{5 + objet} exécute \mintinline{python3}{int.__add__(5)}. Pour que l'opération soit symétrique, il faut aussi définir ces fonctions avec le préfixe \mintinline{python3}{r} (par exemple \mintinline{python3}{__radd__()}).

\section{Fonctions et objets appelables}
La façon la plus basique de définir une fonction est d'utiliser le mot-clé \mintinline{python3}{def}. Lorsque l'on appelle, on spécifie des arguments aux paramètres de la fonction.

\begin{minted}{python3}
fonction(argument_de_paramètre_non_nommé, paramètre_nommé=argument)
\end{minted}

On peut utiliser les opérateurs d'\emph{unpacking} (\og déballage \fg{}) :
\begin{itemize}
    \item Lorsque l'on écrit les paramètres pour capter tous les paramètres possibles.
    \item Pour renseigner les arguments.
\end{itemize}

\paragraph{Exemple}
\begin{minted}{python3}
# Cette fonction accepte tous les arguments
def fonction(*args, **kwargs):
    pass

# Celle-ci en accepte 4. On va tester sur celle-ci l'unpacking.
def fonction(par1, par2, par3, par4):
    for (arg, value) in locals().items():
        print(arg, ':', value)

arg1, arg2, arg3, arg4 = 1, 2, 3, 4
tuple_args = (arg1, arg2)
dict_args = {'par3': arg3, 'par4': arg4}

# Testons l'unpacking
fonction(*tuple_args, **dict_args)

# Sortie
# par4 : 4
# par3 : 3
# par2 : 2
# par1 : 1
\end{minted}


\section{Descripteurs}
Les descripteurs sont une généralisation des propriétés. On dit qu'un objet est un descripteur s'il possède au moins une méthode \mintinline{python3}{__get__()} (accesseur), \mintinline{python3}{__set__()} (mutateur), ou \mintinline{python3}{__delete__()} (destructeur).

\paragraph{Exemple} Exemple d'implémentation
\begin{minted}{python3}
class Attribut:
    def __get__(self, inst, insttype):
        print("Accès à l'attribut")
        return inst._attribut

    def __set__(self, inst, valeur):
        print("Modification de l'attribut")
        inst._attribut = valeur

class MaClasse:
    def __init__(self):
        self._attribut = 'Je suis un attribut'

    attribut = Attribut()
\end{minted}

\paragraph{Plus d'informations} \href{https://docs.python.org/3/howto/descriptor.html}{Documentation Python 3}





\section{Conteneurs}

\paragraph{Remarque préléminaire} Pour les méthodes spéciales spécifiques aux types des parties suivantes, je me base sur le module \hyperref[abc]{\mintinline{python3}{collections.abc}}\bigskip


Les conteneurs sont des objets voués à contenir d'autres objets. Les principaux exemples de conteneurs sont les listes, les chaînes de caractères, les tuples, les dictionnaires ou encore les ensembles. Un objet est dit conteneur s'il possède la méthode spéciale \mintinline{python3}{__contains__()}.

\begin{description}
    \item[\mintinline{python3}{conteneur.__contains__(objet)}]~

    Retourne \mintinline{python3}{True} si \mintinline{python3}{objet} est présent dans \mintinline{python3}{conteneur}, \mintinline{python3}{False} sinon. On appelle cette méthode spéciale comme ceci:
    \begin{minted}{python3}
objet in conteneur
    \end{minted}
\end{description}

\paragraph{Remarque} La fonction \mintinline{python3}{__contains__()} est définie chez les itérateurs, mais ceux-ci ne sont pas pas des conteneurs ! Implémenter cette méthode n'est donc pas une condition suffisante pour qu'un objet soit un conteneur (voir la section sur les \hyperref[iterateur]{itérateurs}).\bigskip

La plupart des conteneurs possède une taille. Elle calculée par la méthode spéciale \mintinline{python3}{__len__()}.
\begin{description}
    \item[\mintinline{python3}{conteneur.__len__()}]~

    Retourne la taille du conteneur. Devrait retourner un entier positif ou nul. Si cette fonction retourne autre chose, une exception est levée. On l'appelle comme ceci:
    \begin{minted}{python3}
len(conteneur)
    \end{minted}
\end{description}
\paragraph{Exemples} Des \og sized \fg{} capricieux
\begin{minted}{python3}
class StrSized:
    def __len__(self):
        return 'Ma taille !'

class NegativeSized:
    def __len__(self):
        return -1

len(StrSized()) # TypeError: 'str' object cannot be interpreted as an integer
len(NegativeSized()) # ValueError: __len__() should return >= 0
\end{minted}

Notons qu'un objet peut avoir une taille sans pour autant être un conteneur (on appelle ça un \emph{sized}).

\subsection{Conteneurs indexables}
Parmi ces conteneurs se distinguent les conteneurs que l'on peut indexer. Ce sont les conteneurs sur lesquels on peut utiliser les crochets \mintinline{python3}{[]} pour faire référence à un objet dans le conteneur; on parle de table de correspondance (\emph{mapping}, non détaillé ici), et de séquence lorsque les index sont des entiers. Parmi les exemples cités précédemment, seuls les ensembles ne sont pas indexables. On rend un objet indexable en implémentant une méthode spéciale.

\begin{description}
    \item[\mintinline{python3}{indexable.__getitem__(index)}]~

    Retourne l'objet référencé par \mintinline{python3}{index} (cet indice peut être n'importe quel objet). Appelée en faisant:
    \begin{minted}{python3}
indexable[index]
    \end{minted}
\end{description}

On peut rendre mutables les objets indexables grâce à deux méthodes spéciales.

\begin{description}
    \item[\mintinline{python3}{indexable.__setitem__(index, valeur)}]~

    Assigne la nouvelle \mintinline{python3}{valeur} à l'objet référencé par \mintinline{python3}{index}. Appel:
    \begin{minted}{python3}
indexable[index] = valeur
    \end{minted}

    \item[\mintinline{python3}{indexable.__delitem__(index)}]~

    Détruit l'objet référencé par \mintinline{python3}{index}. Appel:
    \begin{minted}{python3}
del indexable[index]
    \end{minted}
\end{description}

\subsection{Objets séquentiels}

Les objets séquentiels sont des objets indexables qui n'acceptent que des entiers comme index. <a venir : Slices>


\section{Itérateurs}\label{iterateur}
\index{itérateur}

Les itérateurs sont des objets incontournables en Python, ils sont notamment utilisés lorsque l'on fait une boucle \mintinline{python3}{for}. Les objets itérateurs peuvent être créés par des objets itérables. Des itérables connus sont les listes, les dictionnaires, les tuples, les \mintinline{python3}{range()}.\bigskip

L'intérêt principal des itérateurs est leur faible consommation mémoire: contrairement à un objet conteneur qui prend autant d'espace que d'objets qu'il contient, un itérateur calcule chaque élément lorsqu'il est appelé.

\paragraph{Exemple} Ce qu'il se passe lorsque l'on fait une boucle \mintinline{python3}{for}
\begin{minted}{python3}
>>> L = [0, 1, 2, 3, 4] # les listes sont des objets itérables
>>> for element in L # appelle l'itérateur de l'itérable L
...    print(element) # à chaque ligne, appelle l'élément suivant de l'itérateur
0
1
2
3
4
\end{minted}

Les itérateurs sont implémentés sous forme de classes et doivent respecter le protocole d'itérateur: deux méthodes spéciales doivent être implémentées.
\begin{description}
    \item[\mintinline{python3}{iterateur.__iter__()}]~

    Cette méthode doit retourner l'itérateur lui-même, on peut auparavant y effectuer quelques opérations d’initialisation. Appel:
    \begin{minted}{python3}
iter(iterateur)
    \end{minted}

    \item[\mintinline{python3}{iterateur.__next__()}]~

    Cette méthode retourne l'élément suivant dans la séquence de l'itérateur. Une fois que le dernier élément a été appelé, lève une exception \mintinline{python3}{StopIteration}. Appel:
    \begin{minted}{python3}
next(iterateur)
    \end{minted}
\end{description}

Les itérables doivent quant à eux implémenter la méthode \mintinline{python3}{__iter__()} qui appelle l'itérateur associé. On l'appelle en faisant \mintinline{python3}{iter(objet_iterable)}.

\paragraph{Exemple} Un incrémenteur
\begin{minted}{python3}
class Incrementor:
    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self. n = 0
        return self

    def __next__(self):
        if self.n <= self.max:
            result = self.n
            self.n += 1
            return result
        else:
            raise StopIteration
\end{minted}
On peut maintenant utiliser l'itérateur.
\begin{minted}{python3}
>>> inc = Incrementor(2)
>>> iterator = iter(inc)
>>> next(inc)
0
>>> next(inc)
1
>>> next(inc)
2
>>> next(inc)
Traceback (most recent call last):
  File "<stdin>", line XX, in <module>
    print(next(iterator))
  File "<stdin>", line XX, in __next__
    raise StopIteration
StopIteration
\end{minted}
On peut aussi utiliser une boucle \mintinline{python3}{for} pour itérer notre itérateur.
\begin{minted}{python3}
>>> for i in Incrementor(5):
...    print(i)
0
1
2
3
4
5
\end{minted}

\section{Générateurs}
\index{générateur}

\paragraph{Plus d'informations} \href{https://zestedesavoir.com/tutoriels/954/notions-de-python-avancees/3-further/1-generators/}{L'excellent cours d'Antoine Rozo}
\subsection{Fonction génératrice et mot-clé \mintinline{python3}{yield}}

Les générateurs sont une façon plus simple d'implémenter les itérateurs. Au lieu de créer une classe avec les deux méthodes du protocole d'itération, on définit une fonction qui retourne les résultats avec le mot clé \mintinline{python3}{yield}. Lorsqu'une fonction possède ce mot-clé, l'appeler crée un générateur (rien d'autre n'est exécuté). Un générateur est un itérateur qui possède quelques méthodes supplémentaires (cf. plus bas); ce sont en quelque sorte des itérateurs upgradés. On appelle par abus de langage les fonctions qui retournent des générateurs (des \og fonctions génératrices \fg{}) des générateurs aussi (alors que ce sont de simples fonctions).\bigskip

Pour faire le lien avec les itérateurs, on peut réécrire l'exemple précédent à l'aide d'un générateur.
\begin{minted}{python3}
def incrementor(max):
    n = 0
    while n <= max:
        yield n
        n += 1
\end{minted}

On utilise les générateurs comme des itérateurs (les générateurs sont des itérateurs). Lorsque l'on évalue la méthode \mintinline{python3}{__next__()} sur un générateur (en faisant \mintinline{python3}{next(generateur)}), celui-ci parcourt la fonction génératrice jusqu'au premier \mintinline{python3}{yield} qu'il rencontre, puis s'arrête. Lorsque la méthode \mintinline{python3}{__next__()} est de nouveau appelée, le générateur continue le parcours jusqu'au \mintinline{python3}{yield} suivant, et ainsi de suite. Lorsqu'il n'y en a plus, le générateur lève une exception \mintinline{python3}{StopIteration}.
\begin{minted}{python3}
>>> gen = incrementor(2)
>>> next(gen)
0
>>> next(gen)
1
>>> next(gen)
2
>>> next(gen) # Erreur
StopIteration
>>> for i in incrementor(2):
...    print(i)
0
1
2
\end{minted}

On n'appelle pas la méthode \mintinline{python3}{iter()} sur un générateur. Ainsi, pour réinitialiser le générateur, on doit le recréer en appelant une nouvelle fois la fonction génératrice.

\paragraph{Remarque} Distinction entre fonction génératrice et générateur
\begin{minted}{python3}
>>> incrementor
<function incrementor at 0x00000240AA034D08> # simple fonction
>>> incrementor(1)
<generator object incrementor at 0x00000240A9FC74F8> # générateur
\end{minted}

\subsection{Fonctions supplémentaires}
En plus du mot-clé \mintinline{python3}{yield}, on peut utiliser des fonctions supplémentaires dans les générateurs:
\begin{description}
    \item[\mintinline{python3}{generateur.send()}]~

    Cette méthode permet de communiquer avec le générateur en lui envoyant une valeur. Lorsqu'elle est appelée avec un argument, celui-ci est envoyé au \mintinline{python3}{yield} actuellement atteint, et le générateur reprend le parcours jusqu'au \mintinline{python3}{yield} suivant. Ainsi, appeler cette méthode consomme une itération ! Lorsqu'on utilise cette méthode, il ne faut pas oublier d'affecter \mintinline{python3}{yield} à une variable, sinon l'argument donné par \mintinline{python3}{send} sera perdu. Séquentiellement, cela donne:
    \begin{enumerate}
        \item Le générateur vient d'être créé. On appelle \mintinline{python3}{__next__()}, le générateur parcourt la fonction jusqu'au premier \mintinline{python3}{yield}.
        \item Le générateur rencontre un \mintinline{python3}{yield}. Il envoie ce que le \mintinline{python3}{yield} lui fournit et se met en pause.
        \item Le générateur est à nouveau appelé. Si c'est avec un \mintinline{python3}{send()}, il passe son argument au \mintinline{python3}{yield} qui la donne à la variable à laquelle il est affecté.
        \item Une fois que c'est fait, le générateur reprend le parcours de la fonction jusqu'au \mintinline{python3}{yield} suivant, (retour à l'étape 2).
    \end{enumerate}

\end{description}

\paragraph{Exemple} On reprend l'incrémenteur et on veut pourvoir l'étendre, c'est à dire lui envoyer un nombre et l'ajouter au maximum initial. Pour cela, on modifie la fonction génératrice et on ajoute des \mintinline{python3}{print()} pour voir comment fonctionne \mintinline{python3}{send()} (on utilise les f-strings).
\begin{minted}{python3}
def incrementor(max):
    n = 0
    while n <= max:
        print(f"max_pre : {max}")
        add_max = yield n
        print(f"max_post : {max}")
        print(f"add_max : {add_max}")
        n += 1
        max = max + add_max if add_max else max
\end{minted}
Lorsque l'on appelle \mintinline{python3}{send}, la valeur est stockée dans \mintinline{python3}{add_max}. On peut alors étendre l'incrémenteur.
\begin{minted}{python3}
>>> gen = incrementor(2)
>>> next(gen)   # Le générateur est appelé, il commence le parcours
max_pre : 2     # Il rencontre le premier print()
0               # et un yield : il envoie ce que celui-ci lui fournit...
>>> next(gen)   # et attend qu'on le rappelle !
max_post : 2    # il reprend son parcours
add_max : None  # on voit bien que l'on a rien envoyé au générateur
max_pre : 2
1
>>> next(gen)
max_post : 2
add_max : None  # toujours rien...
max_pre : 2
2
>>> gen.send(3) # Le yield retourne à add_max la valeur de send()
max_post : 2    # le générateur reprend le parcours...
add_max : 3     # On a bien un add_max de 3 !
max_pre : 5     # arrivé au while, le max a donc changé, la boucle peut donc continuer !
3               # et on atteint bien le yield suivant
>>> next(gen)
max_post : 5
add_max : None
max_pre : 5
4
\end{minted}
En fait, on s'aperçoit que \mintinline{python3}{next(gen)} et \mintinline{python3}{gen.send(None)} sont équivalents. On ne peut pas appeler \mintinline{python3}{send()} avec autre chose que \mintinline{python3}{None} en paramètre avant d'avoir appelé au moins une fois \mintinline{python3}{__next__()}. En effet, l'affectation se fait par l'intermédiaire du \mintinline{python3}{yield} actuel.

\begin{description}
    \item[\mintinline{python3}{generateur.throw(type[, value, traceback])}]~

    Envoie une exception au générateur. Si celui-ci l'attrape, alors retourne également la valeur suivante du générateur.

    \item[\mintinline{python3}{generateur.close()}]~

    Envoie une exception au générateur
\end{description}

\section{Coroutines}

\subsection{}

\section{Décorateurs}
\index{décorateur}
Les décorateurs sont des fonctions ou des classes qui permettent de modifier le comportement d'une autre fonction (ou classe). Les décorateurs sont utiles lorsque l'on souhaite qu'un certain nombre de fonctions effectuent des tâches communes comme par exemple donner leur temps d'exécution. On appelle un décorateur de la manière suivante.

\begin{minted}{python3}
@decorateur
def fonction():
    pass
\end{minted}

Le code précédent a le même comportement que le code suivant:

\begin{minted}{python3}
def fonction():
    pass

fonction = decorateur(fonction)
\end{minted}

Ainsi, \mintinline{python3}{fonction} devient l'objet retournée par \mintinline{python3}{decorateur(fonction)}. Le décorateur doit donc retourner un objet que l'on peut appeler en écrivant \mintinline{python3}{objet()} (avec d'éventuels arguments), on appelle ce type d'objet un \og appelable \fg{}\index{appelable}, une généralisation des fonctions. Le décorateur est lui même un appelable. Si on le définit comme une classe, on doit définir la méthode \mintinline{python3}{__call__()} qui permet de rendre ses instances appelables.

\paragraph{Plus d'informations} \href{https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators/1594484#1594484}{Stack Overflow}

\subsection{En tant que classe}
Une façon d'implémenter un décorateur est d'utiliser les classes. La fonction décorée deviendra alors une instance de la classe de ce décorateur. Il faut obligatoirement définir la méthode \mintinline{python3}{__call__()} pour pouvoir rendre cette instance appelable.

\paragraph{Exemple} On considère ici un décorateur qui compte le nombre d'appels de la fonction décorée.
\begin{minted}{python3}
class Compteur:
    def __init__(self, f):
        self.call = 0
        self.f = f

    def __call__(self, *args, **kwargs):
        self.call += 1
        print("La fonction {} a été appelée {} fois.".format(self.f.__name__, self.call))
        return self.f(*args, **kwargs)
\end{minted}


\subsection{En tant que fonction}
Comme un décorateur est un objet appelable qui n'a d'autre utilité que d'être appelé, il est aussi logique de le définir en tant que fonction.

\paragraph{Exemple} Même décorateur que précédemment mais en l'implémentant en tant que fonction.
\begin{minted}{python3}
def compteur(f):
    def wrapper(*args, **kwargs):
        wrapper.call += 1
        print("La fonction {} a été appelée {} fois.".format(f.__name__, wrapper.call))
        return f(*args, **kwargs)
    wrapper.call = 0
    return wrapper
\end{minted}

\paragraph{Remarques} On voit dans cet exemple que l'on peut définir des fonctions dans les définitions de fonctions. La mention \mintinline{python3}{*args} fait référence à tous les arguments non nommés que l'on a entrés (c'est un tuple, par exemple \mintinline{python3}{(arg1, arg2)}). La mention \mintinline{python3}{**kwargs} fait référence aux arguments nommés (c'est un dictionnaire). Ainsi on est sûr de récupérer tous les arguments.\bigskip

Dans cet exemple, on assigne à \mintinline{python3}{wrapper} un attribut de fonction (on peut le faire, puisqu'une fonction est un objet -- de la classe \mintinline{python3}{function}). On le définit après avoir défini cette fonction.

\subsection{Décorateurs à paramètres}
On peut faire en sorte que le décorateur prenne un ou plusieurs paramètres. Dans ce cas, il faut définir le décorateur à l'intérieur d'une clôture qui prend en argument ces différents paramètres.

\paragraph{Exemple} On veut retourner une erreur quand la fonction retourne une valeur trop élevée.
\begin{minted}{python3}
def depasse_max(max):
    def deco(f):
        def wrapper(*args, **kwargs):
            n = f(*args, **kwargs)
            if n > max:
                print("Maximum {} dépassé.".format(max))
                return
            return n
        return wrapper
    return deco
\end{minted}

Ces deux syntaxes sont équivalentes:

\begin{minted}{python3}
# Syntaxe 1
@depasse_max(10)
def demande_nombre():
    n = int(input("Entrer un nombre : "))
    return n

# Syntaxe 2
def demande_nombre():
    n = int(input("Entrer un nombre : "))
    return n

demande_nombre = depasse_max(10)(demande_nombre)
\end{minted}

Cela permet de faire

\begin{minted}{pycon}
>>> demande_nombre()
Entrer un nombre : 11
Maximum 10 dépassé.
\end{minted}


\section{Métaclasses}
\subsection{Principe}
\index{métaclasse}\label{sec:metaclasses}
Les métaclasses sont les classes qui instancient d'autres classes. Par défaut, une seule métaclasse est définie : la métaclasse \mintinline{python3}{type}. On s'en rend compte en demandant le type des classes que l'on crée.

\begin{minted}{python3}
class MaClasse:
    pass

print(type(MaClasse)) # <class 'type'>
\end{minted}

\subsection{La métaclasse \mintinline{python3}{type}}



\subsection{Application pythonique: propriété de classe}
On pourrait imaginer des propriétés de classes afin d'ajouter une couche de logique sur une simple variable de classe. Au lieu de définir un descripteur générique, on créer une métaclasse qui aura comme popriété la future propriété de classe.

\paragraph{Exemple} Un exemple simple
\begin{minted}{python3}
class MaMetaclasse(type):
    @property
    def propriete(self):
        return self._propriete
    @propriete.setter
    def propriete(self, value):
        self._propriete = value

class MaClasse(metaclass=MaMetaclasse):
    _propriete = 5

print(MaClasse.propriete) #5
\end{minted}

\newpage

\part{Bibliotheque standard}

\section{Classes abstraites : abc, collections.abc}\label{abc}

\section{re}
\index{re}\index{expression régulière}
Le module \mintinline{python3}{re} permet d'utiliser les expressions régulières en Python.
\paragraph{Plus d'informations} \href{https://docs.python.org/fr/3/library/re.html}{Documentation Python 3}

\subsection{Ecrire une expression régulière}
Les expressions régulières sont un excellent moyen de retrouver des motifs complexes dans une chaîne de caractères. On écrit les motifs à rechercher grâce à plusieurs caractères spéciaux:
\begin{description}
    \item [Spécification du caractère]~
    \begin{itemize}
        \item \og\mintinline{text}{.}\fg{} désigne n'importe quel caractère.
        \item \og\mintinline{text}{[]}\fg{} permet de dire quels caractères on veut trouver (\mintinline{text}{[a-e]} : \mintinline{text}{a}, \mintinline{text}{b}, \mintinline{text}{c}, \mintinline{text}{d} ou \mintinline{text}{e}; \mintinline{text}{[a-eA-E]} idem avec les majuscule comprises; \mintinline{text}{[+-*]}: soit \mintinline{text}{*} soit \mintinline{text}{+} soit \mintinline{text}{-}).
        \item \og\Verb[fontsize=\small]|\w|\fg{} équivaut à \Verb[fontsize=\small]|[a-zA-Z0-9_]|.
        \item \og\Verb[fontsize=\small]|\W|\fg{} désigne tout caractère non alpha-numérique.
        \item \og\Verb[fontsize=\small]|\d|\fg{} équivaut à \mintinline{text}{[0-9]}.
        \item \og\Verb[fontsize=\small]|\D|\fg{} désigne tout caractère non numérique.
        \item \og\Verb[fontsize=\small]|\s|\fg{} désigne un espace.
    \end{itemize}
    \item [Place du motif dans la chaine]~
    \begin{itemize}
        \item \og\Verb[fontsize=\small]!^!\fg{} (se place au début) signifie que le début de la chaine doit correspondre au motif.
        \item \og\mintinline{text}{\$}\fg{} (se place à la fin) signifie que la fin de la chaine doit correspondre au motif.
    \end{itemize}
    \item [Nombre d'apparition(s) consécutive(s)]~
    \begin{itemize}
        \item \og\mintinline{text}{\{n\}}\fg{} indique que le caractère précédent doit apparaitre \mintinline{text}{n} fois.
        \item \og\mintinline{text}{\{n,m\}}\fg{} indique que le caractère précédent doit apparaitre entre \mintinline{text}{n} et \mintinline{text}{m} fois.
        \item \og\mintinline{text}{*}\fg{} indique que le caractère précédent n'apparait pas ou apparait sans maximum d'occurences (\mintinline{text}{ab*} correspond à \mintinline{text}{a}, \mintinline{text}{ab}, ou bien \mintinline{text}{abbbbbb}, etc.).
        \item \og\mintinline{text}{+}\fg{} indique que le caractère précédent apparait au moins une fois (\mintinline{text}{ab+} correspond à \mintinline{text}{ab}, \mintinline{text}{abb}, ou bien \mintinline{text}{abbbbbb}, etc.).
        \item \og\mintinline{text}{?}\fg{} indique que le caractère précédent apparait au plus une fois (équivalent à \mintinline{text}{\{0,1\}}).
    \end{itemize}
\end{description}

Les quatre derniers qualificateurs sont dits gourmands : ils valident autant de caractères que possible. Par exemple pour \mintinline{python3}{"aaaaa"}, \mintinline{python3}{a\{3,5\}} validera la chaine en entier. Pour une version non gourmande, on suit le qualificateur d'un \mintinline{python3}{?} : \mintinline{python3}{*?}, \mintinline{python3}{+?}, \mintinline{python3}{??} et \mintinline{python3}{\{n,m\}?}. Un qualificateur non gourmand valide le moins de caractères possibles.\bigskip

Pour contrôler le nombre d'apparitions d'un groupe de caractères, on met ceux-ci entre parenthèses (\mintinline{python3}{(abc)+}: \mintinline{python3}{abc}, \mintinline{python3}{abcabc}, etc.). Cela crée un groupe de caractères, on peut le nommer en suivant la parenthèses ouvrante de \mintinline{python3}{?P<nom>}. Cela est utile par exemple quand on veut remplacer des caractères. On peut séparer des expression régulières par un \mintinline{python3}{|} afin d'indiquer que plusieurs possibilités sont possibles.\bigskip

\subsection{Méthodes}
On compile une expression régulière en utilisant la fonction \mintinline{python3}{compile}\marginpar{re.compile}. Cette fonction retourne un objet expression régulière (regex) sur lequel on peut évaluer diverses méthodes. Si l'on cherche une phrase, la syntaxe sera:

\begin{minted}{python3}
import re

regex = re.compile(r"[A-Z]\w*\s?(\w+\s?)*.")
\end{minted}

\paragraph{Remarque} On utilise le préfixe \mintinline{python3}{r} devant la chaine de caractère pour éviter d'avoir à écrire \Verb[fontsize = \small]|\\| au lieu d'un unique \Verb[fontsize = \small]|\|.\bigskip

On peut rechercher toutes les occurences du motif grâce à la méthode \mintinline{python3}{re.finditer(motif, chaine)}\marginpar{regex.finditer}. Cela retourne un objet iterable. On accède aux objets en appelant \mintinline{python3}{next(iterable)}, qui retourne un objet expression rationnelle. Celui-ci contient plusieurs chaînes de caractères (une pour chaque groupe du motif), on y accède en appelant les différents groupes : \mintinline{python3}{objet.group(numéro ou nom)}.\bigskip

\paragraph{Exemple} On veut extraire les phrases d'une chaîne de caractères.
\begin{description}
\item[Script]~

\begin{minted}{python3}
chaine = r"Je suis une phrase. Moi aussi"
regex = re.compile(r"[A-Z]\w*\s?(?:\w+\s?)*.")
resultats = regex.finditer(chaine)
while True:
    try:
        print(next(resultats).group(0))
    except:
        break
\end{minted}
\item[Sortie]~

\begin{minted}{pycon}
Je suis une phrase.
Moi aussi.
\end{minted}
\end{description}

On peut remplacer les motifs par d'autres motifs en utilisant la méthode \mintinline{python3}{re.sub}\marginpar{regex.sub}. Elle prend en paramètres:
\begin{enumerate}
    \item le motif (chaîne de caractères ou objet expression rationnelle.)
    \item le remplacement (peut être une fonction)
    \item la chaine à traiter
    \item \mintinline{python3}{count=}le nombre d'occurences à remplacer
\end{enumerate}
et renvoie la chaine de caractères modifiée. Lorsque l'on veut appeler un groupe de caractères nommé avec \mintinline{python3}{(?P<nom>)}, on y fait référence dans la chaine de remplacement par \Verb[fontsize = \small]|\g<nom>|.

\paragraph{Exemple}
\begin{minted}{python3}
pass
\end{minted}



\section{datetime}\label{datetime}
\index{datetime}

Le module \mintinline{python3}{datetime}\marginpar{\mintinline{python3}{datetime}} permet de créer des objets représentant des dates et de faire des opérations. La classe \mintinline{python3}{datetime.date} représente une date par son année, son mois et son jour: \mintinline{python3}{jour = datetime.date(2017, 1, 1)} correspond à la date 1\ier{} janvier 2017.
La classe \mintinline{python3}{datetime.timedelta} permet de faire des opérations sur les dates. Ses objets sont représentés par un nombre de jours (on peut construire un \mintinline{python3}{timedelta} avec des semaines/mois/années, le constructeur convertit en jours).
Le module \mintinline{python3}{datetime} peut ausi être utilisé pour utiliser des durées plus réduites, i.e.\ secondes, minutes, heures, etc.

\paragraph{Exemple}
\begin{minted}{pycon}
>>> import datetime
>>> j1 = datetime.date(2017, 1, 1)
>>> j2 = j1 + datetime.timedelta(30)
>>> j2
datetime.date(2017, 1, 31)
\end{minted}


\paragraph*{Documentation} \href{https://docs.python.org/fr/3/library/datetime.html}{Documentation Python 3}

\section{functools}
Ce module fournit des outils pour la manipulation de fonctions

\subsection{Préservation de la signature d'une fonction décorée}
Décorer une fonction change sa signature:

\begin{minted}{pycon}
>>> def f():
...     return "Hello!"
...
>>> f()
"Hello!"
>>> f
<function f at 0x0000023CECFFC1E0>
>>> def deco(f):
...     def wrapper():
...         print(f())
...         print("Done.")
...     return wrapper
...
>>> @deco
... def f():
...     return "Hello!"
...
>>> f()
Hello!
Done.
>>> f
<function deco.<locals>.wrapper at 0x0000023CEDB2EF28>
\end{minted}

Le décorateur \mintinline{python3}{@wraps} du module \mintinline{python3}{functools} permet d'y remédier.
\begin{minted}{pycon}
>>> from functools import wraps
>>> def deco(f):
...     @wraps(f)
...     def wrapper(*args, **kwargs):
...         print(f())
...         print("Done.")
...     return wrapper
...
>>> @deco
... def f():
...     return "Hello!"
...
>>> f()
Hello!
Done.
>>> f
<function f at 0x00000223E312DEA0>
\end{minted}

\section{turtle}
\index{turtle}

Contient des classes pour dessiner des formes simples en faisant avancer des tortues. Elles peuvent avancer, reculer, tourner d'un certain angle.
La classe \mintinline{python3}{Turtle} permet de créer des objets tortues qui peuvent :
\begin{enumerate}
        \item Avancer: \mintinline{python3}{Turtle.forward(<nb de pixels>)}
        \item Reculer: \mintinline{python3}{Turtle.backward(<nb de pixels>)}
        \item Tourner à droite ou à gauche (ex: \mintinline{python3}{Turtle.right(<degrés>)})
        \item Changer de couleur (\mintinline{python3}{Turtle.color(<couleur>)}) ou de forme (\mintinline{python3}{Turtle.shape(<forme>)}).
\end{enumerate}

\paragraph{Exemple}
\begin{minted}{python3}
import turtle

Terrain = turtle.Screen()
Terrain.bgcolor("black")

Tortue = turtle.Turtle()
Tortue.speed(3)
Tortue.shape("turtle")
Tortue.color("white")

for i in range(50):
    for e in range(4):
        Tortue.forward(100)
        Tortue.right(90)
    Tortue.right(360/50)

Terrain.exitonclick()
\end{minted}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{turtle.PNG}
\caption*{Résultat}
\end{center}
\end{figure}

\paragraph{Plus d'informations} \href{https://docs.python.org/fr/3.6/library/turtle.html#methods-specific-to-screen-not-inherited-from-turtlescreen}{Documentation Python 3}, \href{https://fr.wikibooks.org/wiki/Programmation_Python/Turtle}{Wikilivres}

\section{ctypes}
\index{ctypes}
 Ce module sert à appeler des fonctions écrites en langage C dans des librairies DLL par exemple.
\subsection{Boites de dialogue}
\index{boîte de dialogue}
 Le module ctypes peut servir à faire apparaître des boites de dialogue. On peut modifier le comportement du script Python en fonction du bouton appuyé car la fonction faisant apparaître ces boites renvoie un entier qui dépend du bouton appuyé. Diverses options sont disponibles :
\begin{minted}{python3}
# Boutons disoponibles :
# 0 : OK
# 1 : OK | Annuler
# 2 : Abandonner | Recommencer | Ignorer
# 3 : Oui | Non | Annuler
# 4 : Oui | Non
# 5 : Recommencer | Annuler
# 6 : Annuler | Recommencer | Continuer

# Icone
# 16 Icone erreur
# 32 Icone question
# 48 Icone attention
# 64 Icone information
\end{minted}

\paragraph{Exemple}
\begin{minted}{python3}
ctypes.windll.user32.MessageBoxW(0, "That's an error", "Warning!", 16)
\end{minted}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{errorwindow.png}
\caption*{Résultat}
\end{center}
\end{figure}

\section{keyboard}\index{keyboard}

\section{os}\index{os}

\section{sys}\index{sys}

\section{threading}\index{threading}

\section{asyncio}\index{asyncio}

\paragraph{Nota Bene} Pour l'instant, cette section sort un peu de nulle part, mais tout s'éclaircira quand la syntaxe des \mintinline{python3}{async} et \mintinline{python3}{await} sera expliquée.\bigskip

Cette bibliothèque permet de facilement effectuer de la programmation asynchrone (à ne pas confondre avec la programmation en parallèle). L'intérêt est de rendre les tâches non-bloquantes, typiquement les requêtes à des serveurs qui peuvent mettre du temps à obtenir une réponse. Cette librairie n'est pas adaptée pour les calculs longs, car elle ne permet pas de calculer plus rapidement !\bigskip

\textbf{Exemple} Voici un code synchrone que l'on peut rendre asynchrone.
\begin{minted}{python3}
import time


def sync_get_response(id, temps_de_reponse):
    time.sleep(temps_de_reponse/1000)  # simulation temps de reponse
    print("Réponse {} reçue !".format(id))


def sync_main():
    sync_get_response(1, 50)
    sync_get_response(2, 50)
    sync_get_response(3, 4000)
    sync_get_response(4, 50)
    sync_get_response(5, 50)
    sync_get_response(6, 6000)
    sync_get_response(7, 50)
    sync_get_response(8, 50)
    sync_get_response(9, 50)

beginning = time.time()
sync_main()
print('Durée', time.time()-beginning)
\end{minted}

\begin{minted}{pycon}
Réponse 1 reçue !
Réponse 2 reçue !
Réponse 3 reçue !
Réponse 4 reçue !
Réponse 5 reçue !
Réponse 6 reçue !
Réponse 7 reçue !
Réponse 8 reçue !
Réponse 9 reçue !
Durée 10.367376565933228
\end{minted}
On remarque que les requêtes longues ralentissent l'exécution du programme. De plus, les requêtes sont effectuées dans l'ordre.


\begin{minted}{python3}
import asyncio
import time


async def get_response(id, temps_de_reponse)
    await asyncio.sleep(temps_de_reponse/1000)
    print("Réponse {} reçue !".format(id))


async def main():
    req1 = loop.create_task(get_response(1, 50))
    req2 = loop.create_task(get_response(2, 50))
    req3 = loop.create_task(get_response(3, 1000)) # simulons une requete longue
    req4 = loop.create_task(get_response(4, 50))
    req5 = loop.create_task(get_response(5, 50))
    req6 = loop.create_task(get_response(6, 1000)) # une autre
    req7 = loop.create_task(get_response(7, 50))
    req8 = loop.create_task(get_response(8, 50))
    req9 = loop.create_task(get_response(9, 50))
    await asyncio.wait([req1, req2, req3, req4, req5, req6, req7, req8, req9])

if __name__ == '__main__':
    beginning = time.time()
    try:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())
    except:
        pass
    finally:
        loop.close()
        print('Durée', time.time()-beginning)

\end{minted}
\begin{minted}{pycon}
Réponse 1 reçue !
Réponse 7 reçue !
Réponse 9 reçue !
Réponse 8 reçue !
Réponse 2 reçue !
Réponse 5 reçue !
Réponse 4 reçue !
Réponse 3 reçue !
Réponse 6 reçue !
Durée 5.994143724441528
# asyncio.sleep() resquillerait-il ? On lui a pourtant demandé de dormir 6 secondes !
\end{minted}
Dans le 2e exemple, le programme n'attend pas de recevoir la réponse pour envoyer les autres requêtes.

\part{Modules à télécharger}
\section{virtualenv}\label{virtualenv}\index{virtualenv}

Les environnement virtuels \marginpar{\href{https://pypi.org/project/virtualenv/}{\mintinline{python3}{virtualenv}}} sont un bon moyen pour:
\begin{enumerate}
    \item Installer des modules sans avoir besoin des droits administrateurs
    \item Avoir plusieurs environnements de travail avec des modules Python de versions différentes. Exemple, j'ai un projet Django 2 et je veux créer un site avec Django-CMS, qui requiert Django 1! Je suis obligé de recourir aux environnements virtuels.
\end{enumerate}

Pour une utilisation basique, on commence par installer \mintinline{python3}{virtualenv} avec \mintinline{python3}{pip}.

\begin{minted}{bash}
$ pip install virtualenv # ou pip3 selon votre version de Python
\end{minted}

Puis on se place dans le dossier où l'on veut placer les environnements virtuels, par exemple sous Linux dans \Verb[fontsize=\small]|/home/votre_nom/python_env/|, et on crée notre environnement!

\begin{minted}{bash}
$ virtualenv env
\end{minted}

Python y place alors les exécutables fondamentaux et quelques modules basiques. Ensuite, pour travailler dans l'environnement créé, il faut lancer la commande:
\begin{minted}{bash}
$ source /home/votre_nom/python_env/env/bin/activate
\end{minted}

L'environnement apparaît maintenant entre parenthèses dans la console. Pour désactiver cet environnement, on lance simplement la commande:

\begin{minted}{bash}
(env) $ deactivate
\end{minted}

Il existe le module \mintinline{python3}{virtualenvwrapper}\marginpar{\href{https://pypi.org/project/virtualenvwrapper/}{\mintinline{text}{virtualenvwrapper}}}\index{virtualenvwrapper} qui permet de naviguer facilement entre les environnements. Après avoir installé ce paquet, il faut ajouter dans le path une variable \mintinline{bash}{WORKON_HOME} qui correspond au répertoire où seront stockés les environnement virtuels. Ensuite on pourra utiliser les commandes

\begin{minted}{bash}
$ mkvirtualenv env # creation d'un environnement virtuel
$ workon # visualisation des environnements existants
env
(env) $ workon env # selection d'un environnement
(env) $ deactivate # quitter cet environnement
\end{minted}

\paragraph{Plus d'informations} \href{https://virtualenv.pypa.io/en/stable/}{Documentation de virtualenv}, \href{http://sametmax.com/les-environnement-virtuels-python-virtualenv-et-virtualenvwrapper/}{informations supplémentaires}


\section{django}\index{django}
Ce \marginpar{\href{https://pypi.org/project/Django/}{\mintinline{python3}{django}}} module permet de créer des sites web en Python. \emph{Il est question ici de la version 2}.
\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/}{Documentation officielle de Django 2.0} \href{https://docs.djangoproject.com/fr/2.0/intro/}{Tutoriel de la documentation}

\subsection{Fonctionnement}

Django fonctionne selon l'architecture Model-View-Template (MVT) que l'on peut traduire par Modèle-Vue-Gabarit. Celle-ci s’appuie sur l'architecture Model-View-Controler (MVC):
\begin{itemize}
	\item Les modèles structurent de la base de données, là où sont stockées toutes les informations. Ici, ce sont des classes Python dont les attributs correspondent à des champs dans la base de données. On n'écrit jamais de SQL avec Django!
	\item Les vues représentent les pages web: elles présentent les informations aux utilisateurs et récupèrent leurs actions. Ici, ce sont des fonctions Python qui prennent en argument la requête (HTTP par exemple) et des informations sur l’URL et qui renvoie, en utilisant les gabarits, la bonne page à l'utilisateur (la bonne réponse HTTP).
	\item Les gabarits permettent de structurer facilement les vues. Ce sont des fichiers HTML avec un peu de syntaxe de gabarit Django.
	\item Le contrôleur fait l'interface entre les vues et les modèles: il récupère et renvoie les informations nécessaires. Cette partie est gérée de manière autonome par Django.
\end{itemize}

\subsection{Didacticiel}
Cette partie s'appuie sur le tutoriel de la documentation Django, ne pas hésiter à s'y rendre pour plus d'infos. Concertant l'installation, il est conseillé d'installer Django dans un \hyperref[virtualenv]{environnement virtuel}. Dans cet environnement, on utilise l'installateur autonome \mintinline{python3}{pip}.

\begin{minted}{bash}
$ pip install Django
\end{minted}

\subsubsection{Créer un projet}
\begin{minted}{bash}
$ django-admin startproject nom_du_projet
\end{minted}

Un dossier est créé, avec trois sous-dossiers (un nommé d'après le projet, un dossier media, et un dossier static) et trois fichiers (une base de données, un fichier python et un fihcier requirements.txt). Pour lancer une première fois le projet sur un serveur local, on utilise la commande (il faut être dans le dossier du projet):
\begin{minted}{bash}
$ python manage.py runserver # on peut remplacer python par python3
\end{minted}
En se rendant sur l’URL indiquée, ou plus simplement \mintinline{python3}{localhost:8000} (on peut modifier le port si l'on veut: on écrit le port souhaité à la suite de la commande précédente), on tombe sur une page nous disant que l'installation de Django a réussi.

\subsubsection{Créer une application}
Une fois le projet créé, on crée une première application (cela peut être un sondage, un blog, etc., les applications sont les blocs du site). Une application peut être réutilisée pour d'autres projets. On crée une application par la commande (en étant dans le répertoire du projet) :
\begin{minted}{bash}
$ python manage.py startapp nom_de_l_application
\end{minted}

\subsubsection{Le fichier \mintinline{python3}{settings.py}}
Il comporte les principaux paramètres du projet. On y renseigne notamment le type de base de données que l'on utilise; si on utilise SQLite, tout est géré automatiquement. On y gère aussi le fuseau horaire, les langues, les applications installées, parmi les suivantes, installées par défaut:
\begin{itemize}
	\item \mintinline{python3}{django.contrib.admin}: l'interface d'administration
	\item \mintinline{python3}{django.contrib.auth}: un système d'authentification
	\item \mintinline{python3}{django.contrib.contenttypes}: une structure pour les types de contenu
	\item \mintinline{python3}{django.contrib.sessions}: un cadre pour les sessions
	\item \mintinline{python3}{django.contrib.messages}: un cadre pour l'envoi de messages
	\item \mintinline{python3}{django.contrib.staticfiles}: une structure pour la prise en charge des fichiers statiques
\end{itemize}

\subsubsection{Migrations}

Ces applications nécessitent des tables dans la base de données. Elles ne sont pas créées lors de la création du projet (d'où un probable message d'erreur lors du premier lancement), on crée les tables nécessaires grâce à la commande:
\begin{minted}{bash}
$ python manage.py migrate
\end{minted}

Il faut relancer cette commande lorsque l'on doit mettre à jour la base de données, typiquement lorsque l'on crée ou modifie des modèles, ou que l'on importe ou crée des applications.

\subsubsection{Structure des fichiers}
La structure des fichiers est la suivante, pour un projet appelé monsite et une application nommée monapplication.

\begin{minted}{text}
monsite/
    manage.py
    monsite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
    monapplication/
        __init__.py
        admin.py
        migrations/
            __init__.py
        models.py
        tests.py
        views.py
\end{minted}

On s'intéresse maintenant à cette application

\subsubsection{Ecrire une vue}
Les vues s'écrivent dans le fichier \mintinline{python3}{views.py}, ce sont des fonctions. On peut commencer par écrire une première vue basique:

\begin{minted}{python3}
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello world!")
\end{minted}

Cette fonction récupère une requette HTTP et renvoie une réponse HTTP. Celle-ci est écrite en HTML ici directement en argument de \mintinline{python3}{HttpResponse()}, en général on n'utilise pas cette façon de faire, on utilise les modèles et les gabarits.

\subsubsection{Lui associer une url}
Il faut associer à la vue que l'on vient de créer une URL, c'est-à-dire la requête associée. On crée donc un fichier \mintinline{python3}{urls.py} dans le répertoire de l'application:
\begin{minted}{python3}
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
\end{minted}

La page \og index \fg{} est par convention (je crois) la page affichée lorsque l'on appelle la racine du projet ou d'une application, c'est pour cela que le premier argument de la fonction \mintinline{python3}{path()} est une chaîne vide. Il faut maintenant relier les URL de l'application aux URL du projet, en modifiant \mintinline{python3}{urls.py} du répertoire racine du projet:

\begin{minted}{python3}
from django.contrib import admin
from django.urls import include
from django.urls import path

urlpatterns = [
    path('monapplication/', include('monapplication.urls')),
    path('admin/', admin.site.urls),
]
\end{minted}

La fonction \mintinline{python3}{include()} permet de faire appel aux autres fichiers d’URL que l'on a créés, il faut toujours utiliser cette fonction, la seule exception étant l'administration. On peut tester en lançant un \mintinline{python3}{runserver}. Si on va sur \mintinline{python3}{localhost:8000}, on a une erreur 404! En se rendant à l'URL \mintinline{python3}{localhost:8000/monapplication/ }, Hello world! apparaît.

\subsubsection{Créer un modèle}
Les modèles structurent la base de données et contiennent des métadonnées. Prenons un exemple musical et créons un modèle \mintinline{python3}{Artiste} et un modèle \mintinline{python3}{Chanson}. On les implémente en tant que classes dans le fichier \mintinline{python3}{models.py}:
\begin{minted}{python3}
from django.db import models

class Artiste(models.Model):
    nom = models.CharField(max_length=100)
    genre = models.CharField(max_length=100)
    bio = models.TextField(max_length=1000)

class Chanson(models.Model):
    titre = models.CharField(max_length=200)
    annee = models.DateTimeField('année de sortie')
    album = models.CharField(max_length=200)
    artiste = models.ForeignKey(Artiste, on_delete=models.CASCADE)
\end{minted}

Les champs sont représentés par des différentes instance de classe \mintinline{python3}{Field}, il en existe divers types. Le premier paramètre non nommé de ces instances permet sert à donner un nom plus lisible à ces champs (ici on l'a utilisé pour \mintinline{python3}{annee}).\bigskip

Une fois ces modèles créés, il faut les activer dans la base de données. Pour cela, il faut commencer par indiquer dans le fichier \mintinline{python3}{settings.py} que l'on a créé une nouvelle application. On ajoute dans \mintinline{python3}{INSTALLED\_APPS} une référence vers la classe de configuration de l'application (qui se trouve dans le fichier \mintinline{python3}{apps.py}). On se trouve donc avec, dans \mintinline{python3}{settings.py}:

\begin{minted}{python3}
INSTALLED_APPS = [
    'monapplication.apps.MonapplicationConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
\end{minted}

On indique alors à Django que les modèles ont été modifiés:
\begin{minted}{bash}
$ python manage.py makemigrations monapplication # on n'est pas obligé de mettre le nom de
                                                 # l'application
\end{minted}

Cette instruction est l'analogue d'un \mintinline{python3}{git stage}, il faut exécuter ensuite la méthode \mintinline{python3}{migrate} pour appliquer les migrations (analogue à \mintinline{python3}{git commit}).

\begin{minted}{bash}
$ python manage.py migrate
\end{minted}

\paragraph{Remarque} Les deux étapes précédentes sont à répéter à chaque fois que l'on a modifié les modèles.

\subsubsection{Interface administrateur}
Il y a deux manières d'interagir avec la base de données:
\begin{enumerate}
    \item Avec l'\href{https://docs.djangoproject.com/fr/2.0/topics/db/queries/}{API Django} (non développé ici) à travers le shell Python.
    \item Avec l'interface graphique administrateur de Django.
\end{enumerate}

L'interface administrateur est créée automatiquement. Pour y accéder, il faut commencer par créer un super-utilisateur.

\begin{minted}{bash}
$ python manage.py createsuperuser
\end{minted}

Il suffit ensuite de suivre la procédure. Une fois cela fini, on peut se rendre (après un \mintinline{python3}{runserver}) sur l'interface à l'adresse \mintinline{python3}{localhost:8000/admin}. Une page de connexion apparaît, on se connecte avec les identifiants du compte super-utilisateur créé précédemment. Après connexion, on arrive sur la page d'administration. Cependant, nous n'avons toujours pas accès aux modèles que l'on a créés. Pour cela, il faut modifier le fichier \mintinline{python3}{admin.py} de l'application:
\begin{minted}{python3}
from django.contrib import admin
from .models import Chanson
from .models import Artiste

admin.site.register(Artiste)
admin.site.register(Chanson)
\end{minted}
Ainsi, les modèles apparaissent dans un bloc correspondant à l'application concernée (\hyperref[admin2]{figure 1}). On peut donc créer une chanson, par exemple (\hyperref[admin3]{figure 2}). On voit que l'on peut renseigner tous les champs que l'on a créés dans nos modèles. L'outil d’administration est donc un outil très puissant qui nous permet d'agir sur la base de données graphiquement!
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=15 cm]{django/admin2.jpg}
        \caption{Administration avec les modèles créés}\label{admin2}
    \end{center}
\end{figure}
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=15 cm]{django/admin3.jpg}
        \caption{Créer une chanson}\label{admin3}
    \end{center}
\end{figure}

Si l'on crée une chanson ou un artiste, on peut voir que dans la liste des objets, apparaît la mention "Chanson object" ou bien "Artiste object". En effet, on n'a pas défini de méthode de représentation dans nos modèles, on peut le faire comme suit:
\begin{minted}{python3}
from django.db import models

class Artiste(models.Model):
    nom = models.CharField(max_length=100)
    genre = models.CharField(max_length=100)
    bio = models.TextField(max_length=1000)

    def __str__(self):
        return self.nom

class Chanson(models.Model):
    titre = models.CharField(max_length=200)
    annee = models.DateTimeField('année de sortie')
    album = models.CharField(max_length=200)
    artiste = models.ForeignKey(Artiste, on_delete=models.CASCADE)

    def __str__(self):
        return self.titre
\end{minted}

En actualisant la page, les noms des artistes et titres de chansons apparaissent bien.

\subsubsection{Introduction aux vues et gabarits}
Créons plus de vues dans le fichier \mintinline{python3}{views.py}. Par exemple des vues qui affichent des artistes et leurs chansons, des vues qui affichent des chansons et leurs paroles. On commence simplement:

\begin{minted}{python3}
def artiste(request, artiste_id):
    return HttpResponse("Vous êtes sur la page de l'artiste {}".format(artiste_id))

def chanson(request, chanson_id):
    return HttpResponse("Vous êtes sur la page de la chanson {}".format(chanson_id))
\end{minted}

Il faut ensuite aller renseigner les URL dans \mintinline{python3}{urls.py}
\begin{minted}{python3}
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index),
    path('chanson/<chanson_id>/', views.chanson),
    path('artiste/<artiste_id>/', views.artiste)
]
\end{minted}

Si on va sur la page \mintinline{python3}{localhost:8000/monapplication/artiste/1}, on voit : \og Vous êtes sur la page de l'artiste 1\fg{}. En effet, Django analyse l'URL de la manière suivante:
\begin{enumerate}
    \item \mintinline{python3}{monapplication/} il va dans les URL de l’application monapplication
    \item \mintinline{python3}{artiste/1/} il cherche la ligne correspondante dans le fichier \mintinline{python3}{urls.py}. Il trouve alors la ligne\\ \Verb[fontsize=\small]|artiste/<artiste_id>|, il appelle donc la vue\\ \Verb[fontsize=\small]|artiste(request=<HttpRequest object>, question_id=1)|.
\end{enumerate}

On peut aussi créer des vues qui interagissent avec la base de données en utilisant l'\href{https://docs.djangoproject.com/fr/2.0/topics/db/queries/}{API Django}. Par exemple les pages racines d'artistes et de chansons pourraient les afficher dans l'ordre alphabétique. On aura finalement le fichier \mintinline{python3}{views.py} suivant.

\begin{minted}{python3}
from django import HttpResponse
from django.shortcuts import render
from .models import Artiste
from .models import Chanson


def index(request):
    return HttpResponse("Hello world!")


def liste_chanson(request):
    liste_chansons = Chanson.objects.order_by('nom')
    context = {
        "liste_chansons": liste_chansons
    }
    return render(request, '/monapplication/chansons/index.html', context)


def liste_artiste(request):
    liste_artistes = Artiste.objects.order_by('nom')
    context = {
        "liste_artistes": liste_artistes
    }
    return render(request, '/monapplication/artistes/index.html', context)


def artiste(request, artiste_id):
    return HttpResponse("Vous êtes sur la page de l'artiste {}"
                        .format(artiste_id))


def chanson(request, chanson_id):
    return HttpResponse("Vous êtes sur la page de la chanson {}"
                        .format(chanson_id))

\end{minted}

On va utiliser des gabarits pour les deux premières vues. La fonction \mintinline{python3}{render()} est un raccourci qui permet de renvoyer une réponse HTTP avec un gabarit. Les gabarits sont des fichiers HTML rangés dans le répertoire \mintinline{python3}{templates} de l'application. Par exemple pour la liste d'artistes, on aura
\begin{minted}{bash}
monapplication/templates/monapplication/artistes/index.html
\end{minted}

Voici un simple gabarit pour la liste des artistes:
\begin{minted}{html}
{% if liste_artistes %}
    <ul>
    {% for artiste in liste_artistes %}
        <li><a href="/monapp/artiste/{{ artiste.id }}/">{{ artiste.nom }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>Aucun artiste.</p>
{% endif %}
\end{minted}

\paragraph{Remarque} Même si dans nos modèles, on ne crée pas d'attribut \mintinline{python3}{id}, celui-ci est créé automatiquement.\bigskip

Il ne faut pas oublier de mettre à jour \mintinline{python3}{urls.py}:
\begin{minted}{python3}
urlpatterns = [
    path('', views.index),
    path('chanson/', views.liste_chanson),
    path('artiste/', views.liste_artiste),
    path('chanson/<chanson_id>/', views.chanson),
    path('artiste/<artiste_id>/', views.artiste)
]
\end{minted}

Ainsi, si vous allez sur \mintinline{python3}{localhost:8000/artiste/}, la liste de vos artistes s'affichera, ou bien \og Aucun artiste. \fg{} sinon.

\subsubsection{Fichiers statiques}

Les fichiers statiques sont rangés dans un répertoire nommé \mintinline{python3}{static}, l'architecture est similaire à celle des gabarits. Imaginons que l'on veuille tout mettre en vert. On crée un fichier \mintinline{python3}{style.css} dans le répertoire assoicé à l'application.

\begin{minted}{css}
html {
    color: green;
}
\end{minted}

On modifie ensuite par exemple le gabarit de la liste des artistes en ajoutant ce code au début:
\begin{minted}{html}
{% load static %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}" />
\end{minted}

La balise de gabarit \Verb[fontsize=\small]|{% load static %}| génère l'URL absolue des fichiers statiques. Si on se rend à la page des artistes, tout est vert !

\subsubsection{Thèmes abordés ici}

Cela marque la fin du didacticiel. On s'intéresse maintenant aux différents aspects de Django:
\begin{enumerate}
    \item Les modèles
    \item Les vues
    \item Les gabarits
    \item Les formulaires
    \item L'administration
    \item Le déploiement
\end{enumerate}

Ce n'est pas exhaustif, la meilleure façon de se documenter reste la documentation officielle (qui est d'ailleurs très bien faite).

\subsection{Les modèles et les opérations sur la base de données}

Comme \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/}{\mintinline{python3}{django.db.models}}} indiqué dans le didacticiel:
\begin{enumerate}
    \item Les modèles sont des classes filles de \mintinline{python3}{models.Model} que l'on écrit dans le fichier \mintinline{python3}{models.py} de l'application concernée.
    \item Cette application doit être mentionnée dans la liste \mintinline{python3}{INSTALLED\_APPS} du fichier \mintinline{python3}{settings.py}
    \item Un modèle correspond à une table de la base de données. Les champs sont les attributs de la classe du modèle.
\end{enumerate}

\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/topics/db/}{Documentation Django 2 --- Portail thématique sur les modèles}

\subsubsection{Les champs: attributs des modèles}

Un champ \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/fields/\#field-types}{\mintinline{python3}{models.Field}}} de modèle doit être une instance de la classe \mintinline{python3}{Field} (où l'une de ses dérivées). Le choix du type de champ détermine le genre de donnée à stocker (par exemple des nombres ou du texte), le composants HTML qui sera utilisé dans le formulaire utilisé pour renseigner ce champs dans l'administration, et enfin les exigences minimales de validation de ce champ. Se référer aux liens dans la marge pour une documentation complète. Quelques types de champs génériques:
\begin{description}
    \item[\mintinline{python3}{class CharField(max_length=None, **options)}]~

    Un champ pour une chaîne de caractère (courte ou longue). Le paramètre \mintinline{python3}{max\_length} règle la taille maximale de ce champ. Il en existe de plus précis pour les mails ou les URL, cf. la doc.

    \item[\mintinline{python3}{class DateField(auto_now=False, auto_now_add=False, **options)}]~

    Une date, représentée par la classe Python \hyperref[datetime]{\mintinline{python3}{datetime.date}}. Le paramètre \mintinline{python3}{auto\_now} permet d'assigner automatiquement la date du jour à chaque enregistrement de l'objet, tandis que \mintinline{python3}{auto\_now\_add} enregistre la date du jour à la création de l'objet.

    \item[\mintinline{python3}{class DateTimeField(auto_now=False, auto_now_add=False, **options)}]~

    Une heure, représentée par la classe Python \mintinline{python3}{datetime.datetime}

    \item[\mintinline{python3}{class IntegerField(**options)}]~

    Un nombre entier compris entre -2147483648 et 2147483647.

    \item[\mintinline{python3}{class TextField(**options)}]~

    Un champ de texte, plus adapté que \mintinline{python3}{CharField} pour les longs textes, car la zone de saisie est plus importante dans le formulaire (on ne détaille pas ici les composants HTML de formulaires, cf. la doc)
\end{description}

\subsubsection{Les relations entre les modèles}

On \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/fields/\#module-django.db.models.fields.related}{\mintinline{python3}{models.ForeignKey}}} peut aussi renseigner les relations entre les modèles (donc entre les tables de la base de données).
\begin{description}
    \item[\mintinline{python3}{class ForeignKey(to, on_delete, **options)}]~

    Une relation plusieurs-à-un, (cf. le didacticiel, exemple des chansons qui ont l'artiste en \mintinline{python3}{ForeignKey}). Cette classe exige la classe à laquelle le modèle et relié, et l'option \mintinline{python3}{on\_delete}: \mintinline{python3}{models.CASCADE} si l'on veut que lorsque l'on supprime la \mintinline{python3}{ForeignKey}, que tous les objets associés du modèle concerné soient supprimés, ou bien \mintinline{python3}{SET\_NULL} si l'on veut que les objets aient la valeur \mintinline{python3}{null} à la place de la \mintinline{python3}{ForeignKey} supprimée (dans ce cas il faut aussi renseigner \mintinline{python3}{null=True}). Il y a d'autres possibilités (cf. la doc), \href{https://docs.djangoproject.com/fr/2.0/topics/db/examples/many_to_one/}{voir des exemples}.

    \item[\mintinline{python3}{class OneToOneField(to, on_delete, parent_link=False, **options)}]~

    Une relation un-à-un, dont le fonctionnement est similaire à \mintinline{python3}{ForeignKey}; \href{https://docs.djangoproject.com/fr/2.0/topics/db/examples/one_to_one/}{voir des exemples}.

    \item[\mintinline{python3}{class ManyToManyField(to, **options)}]~

    Une relation plusieurs-à-plusieurs, qui fonctionne de la même manière que \mintinline{python3}{ForeignKey} (avec d'autres paramètres supplémentaires, cf. la doc); \href{https://docs.djangoproject.com/fr/2.0/topics/db/examples/many_to_many/}{voir des exemples}.
\end{description}

\subsubsection{Les options des champs}
Les champs acceptent des \mintinline{python3}{options}\marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/fields/\#field-options}{\mintinline{python3}{**options}}}, en voici quelques unes (on note après un signe \mintinline{python3}{=} la valeur par défaut):
\begin{description}
    \item[\mintinline{python3}{null=False}]~

    Si la valeur est \mintinline{python3}{True}, alors Django stocke les valeurs vides dans la base de données avec \mintinline{python3}{NULL}.

    \item[\mintinline{python3}{blank=False}]~

    Si la valeur est \mintinline{python3}{True}, alors on peut laisser ce champ vide (cette option agit lors de la validation, ne pas confondre avec le paramètre précédent).

    \item[\mintinline{python3}{choices}]~

    C'est un itérable (tuple ou liste par exemple) constitué de couples \mintinline{python3}{(A, B)} où \mintinline{python3}{A} est la valeur réelle pour le modèle et \mintinline{python3}{B} le texte affiché à l'utilisateur. On peut organiser en sous groupe comme dans cet exemple:

    \begin{minted}{python3}
choix_media = [
    ['Audio', [('vinyl', 'Vinyl'), ('cd', 'CD')]],
    ['Vidéo', [('vhs', 'Cassette VHS'), ('dvd', 'DVD')]],
    ('unknown', 'Unknown'),
]
    \end{minted}

    \item[\mintinline{python3}{default}]~

    C'est la valeur par défaut du champ, cela peut être un objet ou un objet appelable (dans ce cas, il est appelé lors de la création de l'objet). Il ne peut pas s'agir d'un objet muable! En effet, le système de noms de Python ferait que plusieurs instances de modèles seraient référencés vers une même instance de cet objet. Au lieu de cela, on crée une fonction qui retourne cet objet muable.

    \item[\mintinline{python3}{help_text}]~

    C'est une chaîne de caractère qui décrit le champ concerné, utilise lorsque l'on utilise la documentation générée automatiquement par Django.

    \item[\mintinline{python3}{primary_key}]~

    Si la valeur est \mintinline{python3}{True}, alors ce champ représentera une clé primaire du modèle. Si aucun champ n'est renseigné, Django en crée un automatiquement: \mintinline{python3}{id}.

    \item[\mintinline{python3}{verbose_name}]~

    Chaîne de caractère qui est le \og nom verbeux \fg{} de l'attribut, c'est-à-dire un nom humainement compréhensible pour cet attribut. Il sera affiché à la place du nom de l'attribut dans le formulaire de l'administration (Django l'utilise en convertissant les soulignés en espaces). A l'exception des champs de relations, ce nom verbeux peut-être renseigné en tant que premier paramètre non nommé du champ. Pour ces exceptions, on doit nommer cette option.
\end{description}

\subsubsection{Les métadonnées}
On \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/options/}{\mintinline{python3}{Meta}}} peut attribuer des métadonnées à un modèle grâce à une classe \mintinline{python3}{Meta} incorporée dans la classe du modèle. C'est une classe facultative. Elle permet d'enrichir l'interface administrateur. On y renseigne plusieurs options, en voici quelques unes:
\begin{description}
    \item[\mintinline{python3}{ordering="-order_date"}]~

    Définit une méthode de tri des instances d'un modèle. C'est une liste ou un tuple de chaîne de caractères. Chaque chaîne correspond à un nom de champ, préfixé par un \mintinline{python3}{-} si l'on veut que le tri soit descendant (on ne met rien pour un tri ascendant). Les tris sont rangés dans la liste par ordre de priorité (Django trie par rapport au premier critère, puis second, etc.)

    \item[\mintinline{python3}{verbose_name}, \mintinline{python3}{verbose_name_plural}]~

    Noms verbeux (même principe que pour les champs) respectivement dans le cas du singulier et dans le cas du pluriel.

    \item[\mintinline{python3}{db_table}]~

    Nom de la table dans la base de données. Par défaut, Django la nomme \mintinline{python3}{application\_modèle}.
\end{description}

\subsubsection{Les gestionnaires}
Le gestionnaire \marginpar{\href{https://docs.djangoproject.com/fr/2.0/topics/db/managers/}{\mintinline{python3}{models}}\par\quad\href{https://docs.djangoproject.com/fr/2.0/topics/db/managers/}{\mintinline{python3}{.manager}}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/topics/db/managers/}{\mintinline{python3}{.Manager}}} est l'interface par laquelle on fait des requêtes à la base de données avec l'\href{https://docs.djangoproject.com/fr/2.0/topics/db/queries/}{API Django} (voir le didacticiel pour un exemple, dans les vues \mintinline{python3}{liste\_artistes} ou \mintinline{python3}{liste\_chansons}. Le gestionnaire permet aussi bien d'inspecter la base de données que de la modifier.

\begin{description}
    \item[\mintinline{python3}{class Manager}]~

    Gestionnaire de la classe concernée. Par défaut, on a (on ne l'écrit pas mais c'est comme-ci):
    \begin{minted}{python3}
class Modèle:
    # ...
    objects = models.Manager()
    \end{minted}

    On peut définir un gestionnaire personnalisé (par exemple pour une classe \mintinline{python3}{Personne}, on peut le nommer \mintinline{python3}{personnes}), dans ce cas, \mintinline{python3}{Modèle.objects} produira une exception \mintinline{python3}{AttributeError}. Si l'on veut définir un gestionnaire avec des méthodes personnalisées, il suffit de créer une classe héritant de \mintinline{python3}{Manager}.
\end{description}

\subsubsection{Modifier la base de données}
L'administration \marginpar{\mintinline{python3}{models}\par\quad\mintinline{python3}{.base}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/ref/models/instances/}{\mintinline{python3}{.Model}}} permet de facilement modifier la base de données à la main, mais on doit utiliser l'API Django si on veut modifier la base de données à partir des vues ou des modèles eux-mêmes (par exemple, en reprenant l'exemple du didacticiel, on peut imaginer que la sauvegarde d'un objet Chanson dans la base de données entraînera la création et sauvegarde de l'objet Artiste associé s'il n'existe pas).\bigskip

Pour insérer un objet dans la table de données, on commence déjà par l'instancier. Comme indiqué dans le didacticiel, tous les modèles héritent de la classe \mintinline{python3}{Model}.

\begin{description}
    \item[\mintinline{python3}{class Model}]~

    Tous les modèles doivent hériter de cette classe! Ainsi on a accès à toutes les méthodes définies par défaut. Il est déconseillé de surcharger l'initialiseur \mintinline{python3}{__init__()}, car cela pourrait entraîner des erreurs. Il est conseillé de créer un gestionnaire personnalisé (une classe qui hérite de \mintinline{python3}{Manager}) et d'y écrire la méthode personnalisée.
\end{description}

Une fois les objets créés, on peut modifier leurs attributs (donc leurs futurs champs). Pour les inclure dans la base de données, il faut les sauvegarder. La première étape consiste à valider l'instance.

\begin{description}
    \item[\mintinline{python3}{Model.clean_fields(self, exclude=None)}]~

    Cette méthode valide les champs de l'instance (typiquement, lève une erreur si un champ est vide, alors qu'on n'a pas le paramètre \mintinline{python3}{blank=True}). L'option \mintinline{python3}{exclude} permet d'indiquer des champs à ignorer lors de la validation. Si la validation échoue, lève une exception \mintinline{python3}{ValidationError}.

    \item[\mintinline{python3}{Model.clean(self)}]~

    Une méthode à personnaliser pour effectuer des méthodes personnalisées sur notre modèle (effectuer automatiquement des valeurs à des champs, effectuer des validations qui demandent de vérifier plusieurs champs simultanément par exemple). Devrait lever une exception \mintinline{python3}{ValidationError} si échoue.

    \item[\mintinline{python3}{Model.validate_unique(self, exclude=None)}]~

    Vérifie les contraintes d'unicité du modèle et lève une \mintinline{python3}{ValidationError} si échoue.

    \item[\mintinline{python3}{Model.full_clean(self, exclude=None, validate_unique=True)}]~

    Exécute les trois méthodes précédentes (exécute \mintinline{python3}{validate\_unique} si le paramètre correspondant est \mintinline{python3}{True}).
\end{description}

\subsubsection{Récupérer des informations de la base de données}
Lorsque \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/}{\mintinline{python3}{models}}\par\quad\href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/}{\mintinline{python3}{.query}}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/}{\mintinline{python3}{.QuerySet}}} l'on veut récupérer des informations de la base de données, on utilise l'API Django. Différentes méthodes appliquées sur les gestionnaires des modèles permettent d'obtenir des objets \mintinline{python3}{QuerySet} qui contiennent les informations désirées. En résumé, on utilise la syntaxe:
\begin{minted}{python3}
# schéma
query_set = Modèle.gestionnaire.methode()
# exemple
liste_artistes = Artiste.objects.all() #  objects est le nom par défaut du gestionnaire
# on peut aussi appeler ces méthodes sur des QuerySet
liste_artistes_inversee = liste_artistes.reverse()
\end{minted}
 Voici quelques méthodes qui renvoient un \mintinline{python3}{QuerySet}:

\begin{description}
    \item[\mintinline{python3}{gestionnaire.all()}]~

    Renvoie un \mintinline{python3}{QuerySet} contenant toutes les entrées de la table.

    \item[\mintinline{python3}{gestionnaire.filter(**kwargs)}]~

    Renvoie un \mintinline{python3}{QuerySet} contenant tous les objets répondant aux \href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/#field-lookups}{paramètres rentrés}.

    \item[\mintinline{python3}{gestionnaire.exclude(**kwargs)}]~

    Renvoie un \mintinline{python3}{QuerySet} contenant tous les objets sauf ceux répondant aux \href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/#field-lookups}{paramètres rentrés}.

    \item[\mintinline{python3}{gestionnaire.reverse(**kwargs)}]~

    Renvoie le \mintinline{python3}{QuerySet} dans l'ordre inverse.

    \item[\mintinline{python3}{gestionnaire.distinct(**kwargs)}]~

    Renvoie un \mintinline{python3}{QuerySet} sans doublon.
\end{description}

Il y a plusieurs façons d'exploiter un \mintinline{python3}{QuerySet}:
\begin{itemize}
    \item Ils sont itérables:
    \begin{minted}{python3}
# On imagine qu'on a déjà un QuerySet, on reprend le modèle du didacticiel
>>> liste_artistes
<QuerySet [<Artiste: Muse>, <Artiste: Keane>, <Artiste: Imagine Dragons>]>
>>> for artiste in liste_artistes:
...    print(artiste.nom)
...
Muse
Keane
Imagine Dragons
    \end{minted}

    \item On peut facilement récupérer le nombre d'éléments
    \begin{minted}{python3}
>>> len(liste_artistes)
3
    \end{minted}

    \item On peut convertir le \mintinline{python3}{QuerySet} en liste:
    \begin{minted}{python3}
>>> L = list(liste_artistes)
>>> L
[<Artiste: Muse>, <Artiste: Keane>, <Artiste: Imagine Dragons]
    \end{minted}

    \item Il existe des méthodes qui évaluent un \mintinline{python3}{QuerySet} et qui renvoient autre chose qu'un \mintinline{python3}{QuerySet}. En voici quelques unes.

    \begin{description}
        \item[\mintinline{python3}{query_set.get(**kwargs)}]~

        Renvoie \emph{l'unique} objet répondant aux paramètres rentrés. S'il existe plusieurs objets possibles, ou zéro objet possible, cette fonction renvoie une erreur (respectivement \mintinline{python3}{MultipleObjectsReturned} et \mintinline{python3}{DoesNotExist}). Si une requête renvoie un \mintinline{python3}{QuerySet} singleton, on peut directement récupérer l'objet avec cette méthode sans paramètre (c'est risqué).

        \item[\mintinline{python3}{query_set.get_or_create(defaults=None, **kwargs)}]~

        Même comportement que ci-dessus, sauf que si l'objet n'existe pas, il est créé. Renvoie un tuple \mintinline{python3}{objet, créé} où \mintinline{python3}{objet} est l'objet créé ou charge, \mintinline{python3}{créé} un booléen: \mintinline{python3}{True} si l'objet a été créé et \mintinline{python3}{False} sinon. Cette méthode permet d'alléger la syntaxe et d'éviter d'avoir recours à \mintinline{python3}{try: ... except: ...}. Les méthodes permettant d'agir sur la base de données sont détaillées plus loin.

        \item[\mintinline{python3}{query_set.update_or_create(defaults=None, **kwargs)}]~

        Essaie de trouver un objet correspondant aux paramètres et lui assigne les nouvelles valeurs rentrées, et crée l'objet s'il n'existe pas. Renvoie la même chose que la méthode précédente.

        \item[\mintinline{python3}{query_set.last()}]~

        Renvoie le dernier objet d'un \mintinline{python3}{QuerySet} (si ce dernier n'est pas trié, il est automatiquement trié selon la clé primaire).

        \item[\mintinline{python3}{query_set.first()}]~

        Idem que la méthode précédente mais renvoie le premier objet.

        \item[\mintinline{python3}{query_set.latest(*fields)}]~

        Renvoie l'objet le plus récent selon le champ indiqué (on les indique de la même manière que pour \mintinline{python3}{ordering}).

        \item[\mintinline{python3}{query_set.earliest(*fields)}]~

        Idem que la méthode précédente mais renvoie le plus ancien.

    \end{description}
\end{itemize}

\subsection{Les requêtes HTTP: vues et URL}
Comme \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/request-response/}{\mintinline{python3}{django.http}}}indiqué dans le didacticiel:
\begin{enumerate}
    \item Les vues sont des fonctions, rangées dans le fichier \mintinline{python3}{views.py} de l'application.
    \item Elles prennent en paramètre obligatoirement une requête Web (à laquelle peuvent s'ajouter des paramètres facultatifs) et renvoient une réponse Web.
    \item La gestion des URL associées aux vues se fait dans le fichier \mintinline{python3}{urls.py}.
\end{enumerate}

\paragraph{Plus d'informations} Documentation Django 2 --- \href{https://docs.djangoproject.com/fr/2.0/topics/http/views/}{Ecriture des vues} ---  \href{https://docs.djangoproject.com/fr/2.0/topics/http/urls/}{Distribution des URL}

\subsubsection{Requêtes HTTP}
Les \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/request-response/\#httprequest-objects}{\mintinline{python3}{http.HttpRequest}}} vues manipulent des requêtes HTTP et renvoient une réponse HTTP en utilisant les modèles et les gabarits. Elles prennent en paramètres une requête HTTP et d'éventuels paramètres supplémentaires dans l'URL (cf. le didacticiel). On commence par décrire ce qu'est une requête HTTP pour Django.

\begin{description}
    \item[\mintinline{python3}{class HttpRequest}]~

    Lorsque Django reçoit une requête HTTP, il crée une instance de cette classe contenant les métadonnées associées à la requête. Elle est ensuite mise en premier paramètre de la vue appropriée (ce paramètre est par convention nommé \mintinline{python3}{request}, cf. les exemples dans le didacticiel). Cette classe présente plusieurs attributs et méthodes (voir la doc).
\end{description}

\subsubsection{Réponse HTTP}
On \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/request-response/\#httpresponse-objects}{\mintinline{python3}{http.HttpResponse}}} s'intéresse maintenant à ce que les vues renvoient: les réponses HTTP.

\begin{description}
    \item[\mintinline{python3}{class HttpResponse}]~

    Cette classe hérite de \mintinline{python3}{HttpResponseBase}. Les réponses HTTP ne sont pas créées automatiquement par Django, ce sont les vues qui les créent. \emph{Une vue se doit de retourner une réponse HTTP!} Typiquement, on peut créer une réponse HTTP avec comme unique paramètre une chaîne de caractère qui sera le contenu de la page HTML retournée.

    \begin{minted}{python3}
response = HttpResponse("Voici du texte de page Web.")
    \end{minted}

    Quelques attributs:

    \begin{description}
        \item[\mintinline{python3}{HttpResponse.content}]~

        Une chaîne de caractères qui représente le contenu de la réponse.

        \item[\mintinline{python3}{HttpResponse.status_code}]~

        Code HTTP de la réponse, 200 par défaut (succès de la réponse). Des classes filles de \mintinline{python3}{HttpResponse} ont une valeur par défaut différente.
    \end{description}

    Il existe aussi diverses méthodes (cf. la doc).

    \item[\mintinline{python3}{class HttpResponseNotFound(HttpResponse)}]~

    Exemple de classe fille de \mintinline{python3}{HttpResponse}, identique à sa classe mère à l'exception de son code HTTP, ici, 404. Il en existe d'autres (voir la doc).
\end{description}

Comme \marginpar{\href{https://docs.djangoproject.com/fr/2.0/topics/http/shortcuts/\#render}{\mintinline{python3}{django}}\par\quad\href{https://docs.djangoproject.com/fr/2.0/topics/http/shortcuts/\#render}{\mintinline{python3}{.shortcuts}}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/topics/http/shortcuts/\#render}{\mintinline{python3}{.render}}} premier paramètre (c'est-à-dire \mintinline{python3}{content}), on peut utiliser une méthode de gabarit, la méthode \mintinline{python3}{render}, qui permet de renvoyer du HTML en utilisant les gabarits. Il existe le raccourci \mintinline{python3}{render} pour alléger le code:

\begin{description}
    \item[\mintinline{python3}{render(request, template_name, context=None, content_type=None, status=None, using=None)}]~

    Fonction qui combine un gabarit avec dictionnaire de contexte et renvoie une \mintinline{python3}{HttpResponse} avec le texte résultant. Deux paramètres obligatoires: \mintinline{python3}{request} et \mintinline{python3}{template\_name}, le nom complet du gabarit à utiliser.
\end{description}

Les deux vues suivantes sont équivalentes (issus de la doc
 Django):
\begin{minted}{python3}
from django.shortcuts import render
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
\end{minted}

\begin{minted}{python3}
from django.http import HttpResponse
from django.template import loader
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
\end{minted}


\subsubsection{La gestion des URL}
Les URL \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/urls/}{\mintinline{python3}{django.urls}}} (Uniforme Resource Locators) sont gérés dans les différents fichiers \mintinline{python3}{urls.py}. Il y en a un dans chaque application et un dans le répertoire racine. Les URL sont configurées dans la liste \mintinline{python3}{urlpatterns}. Voici les principales fonctions à utiliser.

\begin{description}
    \item[\mintinline{python3}{path(route, view, kwargs=None, name=None)}]~

    Cette fonction est utilisée dans la liste \mintinline{python3}{urlpatterns}. Elle prend deux paramètres obligatoires: la route, une chaîne de caractère qui correspond à une URL, et une vue (ou bien la fonction \mintinline{python3}{include} qui appelle d'autres URL). La route peut contenir des éléments entre chevrons \mintinline{python3}{<paramètre>} qui servent de paramètres pour la vue (rappel: les vues sont des fonctions).

    \item[\mintinline{python3}{include(module, namespace=None)}]~

    Cette fonction, en général utilisée comme second paramètre de la fonction \mintinline{python3}{path()} prend en argument un module d'URL qu'il faut inclure après l'URL mise en premier paramètre.
\end{description}


\subsection{Les gabarits}
Un gabarit Django est un fichier texte ou une chaîne de caractères Python balisée en utilisant le langage de gabarit Django. Certaines expressions (étiquettes et variables) sont reconnues et inerprétées par le moteur de gabarit. Pour rendre un gabarit, celui-ci a besoin d'un dictionnaire de contexte: il remplace les variables par leur valeur et exécute les étiquettes. Le reste est maintenu tel quel.

\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/topics/templates/}{Documentation Django 2}


\subsubsection{La syntaxe des gabarits}
\paragraph{Les variables}
Elles utilisent le dictionnaire de contexte pour afficher leur valeur correspondante. Les noms des variables sont les clés du dictionnaire. Dans le gabarit, les variables sont entourées de doubles accolades: \mintinline{python3}{\{\{} et \mintinline{python3}{\}\}}. Par exemple, le gabarit
\begin{minted}{text}
La chanson {{ chanson }} a été écrite par {{ artiste }}.
\end{minted}
avec le dictionnaire \mintinline{python3}{\{'artiste': 'Muse', 'chanson': 'Starlight'\}} donnera:
\begin{minted}{text}
La chanson Starlight a été écrite par Muse.
\end{minted}

On accèdes aux attributs d'instances, aux indices de listes, aux clés de dictionnaires par une notation pointée.
\begin{minted}{text}
{{ dico.clé }}
{{ objet.attribut }}
{{ liste.indice }}
\end{minted}

Si la valeur de la variable est une fonction (ou n'importe quel objet appealble), il sera appelé sans paramètre et le résultat retourné sera utilisé.

\paragraph{Les balises} Elles \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/templates/builtins/\#built-in-tag-reference}{Balises intégrées}}permettent de faire diverses choses, comme utiliser des boucles logiques ou insérer d'autres gabarits. Leur nom sont entourés de \mintinline{python3}{\{\%} et \mintinline{python3}{\%\}}. Certaines balises sont orphelines, les autres s'utilisent comme ceci:

\begin{minted}{html}
<!-- Exemple de balise nommée balise. -->
{% balise %}
<!-- Contenu -->
{% endbalise %}
\end{minted}

\begin{description}
    \item[\mintinline{python3}{block}] (oprheline)

    Définit un bloc pouvant être surchargé par des gabarits enfants.

    \item[\mintinline{python3}{comment}]~

    Ignore ce qui est compris entre \mintinline{python3}{\{\% comment \%\}} et \mintinline{python3}{\{\% endcomment \%\}}.

    \item[\mintinline{python3}{if}]~

    Evalue une variable et, si celle-ci vaut \mintinline{python3}{True} (ie est différent de \mintinline{python3}{False}, \mintinline{python3}{''} ou \mintinline{python3}{None}), affiche le bloc correspondant.

    \begin{minted}{html}
{% if var_1 %}
    <!-- contenu -->
{% elif var_2 > var_3 %}
    <!-- contenu -->
{% elif var_4 and var_5 or var_6 %}
    <!-- OR est prioritaire sur AND.
    Utiliser des parenthèses est une erreur de syntaxe,
    utiliser des IF imbriqués si nécessaire. -->
{% elif var_7 in var_8 %}
    <!-- contenu -->
{% elif var_9 is not var_10 %}
    <!-- contenu -->
{% endif %}
    \end{minted}

    \item[\mintinline{python3}{firstof}] (orpheline)

    Affiche le premier paramètre qui ne vaut pas \mintinline{python3}{False} et rien dans le cas où aucun paramètre n'est vrai. On peut ajouter un dernier paramètre si aucun n'est validé. On peut utiliser le mot clé \mintinline{python3}{as} pour stocker la variable (voir \mintinline{python3}{cycle} un peu plus bas).

    \begin{minted}{html}
{% firstof var1 var2 var3 "dernier recours" %}
<!-- est l'équivalent de -->
{% if var1 %}
    {{ var1 }}
{% elif var2 %}
    {{ var2 }}
{% elif var3 %}
    {{ var3 }}
{% else %}
    "dernier recours"
{% endif %}
    \end{minted}

    \item[\mintinline{python3}{for}]~

    Effectue une boucle sur chaque élément d'une liste. On peut ensuite utiliser cet élément comme variable. Exemple:
    \begin{minted}{html}
<ul>
{% for artiste in liste_artistes %}
    <li>{{ artiste.nom }}</li>
{% endfor %}
</ul>
    \end{minted}

    On peut ajouter une balise \mintinline{html}{{% empty %}} pour afficher du contenu lorsque la liste est vide (ou n'existe pas).

    \item[\mintinline{python3}{cycle}] (orpheline)

    Affiche un de ses paramètres à chaque apparition de la balise: le premier, puis le deuxième, et ainsi de suite; et revient au début lorsque tous les paramètres ont été utilisés. On peut mélanger variables et chaînes de caractères, par exemple:

    \begin{minted}{html}
{% for elemt in liste %}
    <div class="{% cycle 'chaine_1' variable_de_la_chaine_2 'chaine_3' %}">
        <!-- contenu -->
    </div>
{% endfor %}
    \end{minted}
    A la première itération, \mintinline{python3}{"chaine\_1"} sera utilisé, puis la chaîne contenu dans \mintinline{python3}{variable\_de\_la\_chaine\_2}, puis \mintinline{python3}{"chaine\_3"}. Il est également possible de sauvegarder temporairement le paramètre dans une variable que l'on peut réutiliser plus loin.

    \begin{minted}{html}
{% for elemt in liste %}
    <div class="{% cycle 'chaine_1' 'chaine_2' as chaine %}">
        <!-- contenu -->
    </div>
    <div class="{{ chaine }}">
    </div>
{% endfor %}
    \end{minted}

\end{description}

\subsubsection{Utiliser les gabarits dans les vues}


\subsection{Les formulaires}
\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/topics/forms/}{Documentation Django 2 --- Les formulaires}

\section{WSGI}
Ce module permet de faire tourner Python sur un serveur comme Apache. On voit ici comment déployer une application Flask ou Django avec Apache 2.4 sur un système d'exploitation Debian 9 (Stretch). On considère qu'Apache est connu. Premièrement, installer le module d'Apache pour Python 3:

\begin{minted}{bash}
$ sudo apt install libapache2-mod-wsgi-py3
\end{minted}

\subsection{Déploiement de Flask}
\subsubsection{Hôte virtuel}

Notre application respecte l'arborescence:
\begin{minted}{bash}
app/
|---flaskapp.wsgi
|---FlaskApp/
    |---__init__.py
    ...
\end{minted}

On crée un hôte virtuel pour notre application Flask.

\begin{minted}{bash}
$ cd /etc/apache2/sites-availables
\end{minted}

\begin{minted}{text}
<VirtualHost *:80>
    ServerName domain.com
    ServerAdmin youremail@email.com
    WSGIScriptAlias / /var/www/chemin/votre/app/flaskapp.wsgi

    <Directory /var/www/chemin/votre/app/FlaskApp>
        Require all granted # signifie que toute requête est acceptée
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/FlaskApp-error.log
    LogLevel warn
    CustomLog ${APACHE_LOG_DIR}/FlaskApp-access.log combined
</VirtualHost>
\end{minted}

On peut prendre n'importe quel nom pour les logs.

Voici le contenu de notre fichier WSGI :

\begin{minted}{python3}
#!/usr/bin/python
# on dit à Debian d'utiliser python3

import sys
import logging

logging.basicConfig(stream=sys.stderr)
sys.path.insert(0,"/var/www/chemin/votre/app/")

# en assumant que l'on a app=Flask(__name__)
from FlaskApp import app as application
\end{minted}

Voilà! Normalemnt ça marche :) À tester avec un Hello World.


\section{twilio}
\index{twilio}
\section{win10toast}
\index{win10toast}
\section{splinter}
\index{splinter}
\section{pylint}
\index{pylint}

\subsection{autopy}
\index{autopy}

\part{Conventions des Python Enhancement Proposals}
\section{PEP 8 : Conventions de style du code Python}
\section{PEP 257 : Convention des docstrings}


\printindex
\end{document}
