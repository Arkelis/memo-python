\documentclass[a4paper, 10pt]{article}
\usepackage[french]{babel}
\usepackage[left = 3 cm, right = 2 cm, top = 2 cm, bottom = 2 cm]{geometry}
\usepackage{makeidx}
\makeindex
\usepackage{fontspec}
\usepackage[langlinenos, draft=false]{minted}
%% Décommenter si Windows
% \setmainfont{Linux Libertine}
% \setsansfont{Linux Biolinum}
%% Décommenter si sur Linux
\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}
\setmonofont{Consolas}
\setminted{fontsize=\footnotesize, frame=single}
\setmintedinline{fontsize=\footnotesize}
\usepackage{xcolor}
\usepackage{color}
%\rmfamily % To load Latin Modern Roman and enable the following NFSS declarations.
% Declare that Latin Modern Roman (lmr) should take
% its bold (b) and bold extended (bx) weight, and small capital (sc) shape,
% from the corresponding Computer Modern Roman (cmr) font, for the T1 font encoding.
%\DeclareFontShape{T1}{lmr}{b}{sc}{<->ssub*cmr/bx/sc}{}
%\DeclareFontShape{T1}{lmr}{bx}{sc}{<->ssub*cmr/bx/sc}{}
\usepackage[colorlinks=true]{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=blue,colorlinks=true}
\usepackage{sectsty}
\allsectionsfont{\bfseries\sffamily}
\usepackage{caption}
\usepackage{graphicx}
\setlength\parindent{0pt}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{myblue}{rgb}{0,0,1}
% \usepackage{titlesec}
\usepackage{titletoc}
\setcounter{tocdepth}{3}
\reversemarginpar
\setlength{\marginparwidth}{2.4cm}
\usepackage{enumitem}

\titlecontents
	{section}
	[0em]
	{\addvspace{0.5em}}
	{{\thecontentslabel.\ }}
	{}
	{\hfill\contentspage}
	[\addvspace{0pt}]

\titlecontents
	{subsection}
	[1em]
	{\addvspace{0.25em}}
	{\thecontentslabel.\ }
	{}
	{\hfill\contentspage}
    [\addvspace{0pt}]

\titlecontents
	{subsubsection}
	[2em]
	{\addvspace{0.25em}}
	{\thecontentslabel.\ }
	{}
	{\hfill\contentspage}
    [\addvspace{0pt}]

% Réinitialise les numéros de sections à chaque partie
\makeatletter
\@addtoreset{section}{part}
\makeatother 

\begin{document}

\definecolor{fondsolarized}{RGB}{253,246,227}
\definecolor{blanc}{RGB}{255, 255, 255}

\begin{center}
	{\Huge{\sc\bfseries{Mémo Python}}}\\[20pt]
	\includegraphics[scale=0.07]{python.png}
	\vspace{20pt}
\end{center}

\tableofcontents

\hypersetup{linkcolor=blue}

\newpage
\section*{Avant de commencer (sauf pour les impatients)}

Je \marginpar{\href{http://python.pycolore.fr}{Permalien}} rédige ce pdf au fur et à mesure que j'en apprends sur Python... Bonne lecture!\bigskip

Ne sont pas reprises les opérations \og basiques \fg{} (boucles, manipulation des listes). On s'intéresse directement à la programmation orientée objet. Ensuite sont détaillés quelques fonctionnalités apportées par des modules. Une partie sur Django est particulièrement plus développée.\bigskip

Sauf exception, on considère qu'on travaille sur \textbf{Python 3.7} et sur une distribution GNU/Linux (par exemple: Linux Mint, Fedora, Solus, Debian, Arch Linux).\bigskip

De nombreux liens sont disponibles. De manière générale:
\begin{enumerate}
	\item Des liens vers les documentations sont fournis.
	\item Des liens plus précis sont fournis en cliquant sur les termes dans la marge. < en cours! (càd incomplet)
	\item Pour le reste, tout ce qui est en bleu = lien (sauf dans les cadres de code).
\end{enumerate}\bigskip

Ce document est écrit au format TeX puis compilé avec XeLaTeX (et minted pour les sections de code) tantôt sur Windows, tantôt sur Fedora (ça ne change pas le résultat). Il est disponible au téléchargement (pour mettre le document à jour) en cliquant sur ce lien: \href{https://python.pycolore.fr}{python.pycolore.fr}.

\paragraph{Notation} Toutes les fonctions sont notées avec des parenthèses : \mintinline{python3}{function()}.
\bigskip

\paragraph{Auteur} Guillaume Fayard.

\newpage
\part{Programmation orientée objet en Python}

\input{POO/Classes}
\input{POO/Methodes_speciales}
\input{POO/Fonctions}
\input{POO/Descripteurs}
\input{POO/Conteneurs}
\input{POO/Iterateurs}
\input{POO/Generateurs}

\section{Coroutines}
\subsection{Objets \emph{awaitables}}

\input{POO/Decorateurs}

\section{Métaclasses}
\subsection{Principe}
\index{métaclasse}\label{sec:metaclasses}
Les métaclasses sont les classes qui instancient d'autres classes. Par défaut, une seule métaclasse est définie : la métaclasse \mintinline{python3}{type}. On s'en rend compte en demandant le type des classes que l'on crée.

\begin{minted}{python3}
class MaClasse:
    pass

print(type(MaClasse)) # <class 'type'>
\end{minted}

\subsection{La métaclasse \mintinline{python3}{type}}



\subsection{Application pythonique: propriété de classe}
On pourrait imaginer des propriétés de classes afin d'ajouter une couche de logique sur une simple variable de classe. Au lieu de définir un descripteur générique, on créer une métaclasse qui aura comme popriété la future propriété de classe.

\paragraph{Exemple} Un exemple simple
\begin{minted}{python3}
class MaMetaclasse(type):
    @property
    def propriete(self):
        return self._propriete
    @propriete.setter
    def propriete(self, value):
        self._propriete = value

class MaClasse(metaclass=MaMetaclasse):
    _propriete = 5

print(MaClasse.propriete) #5
\end{minted}

\newpage

\part{Bibliothèque standard}

\section{\texttt{abc}, \texttt{collections.abc} --- Classes mères abstraites}\label{abc}

\section{\texttt{re} --- Expressions régulières}
\index{re}\index{expression régulière}
Le module \mintinline{python3}{re} \marginpar{\href{https://docs.python.org/fr/3/library/re.html}{\mintinline{python3}{re}}} permet d'utiliser les expressions régulières en Python.
\paragraph{Plus d'informations} \href{https://docs.python.org/fr/3/library/re.html}{Documentation Python 3}

\subsection{Ecrire une expression régulière}
Les expressions régulières sont un excellent moyen de retrouver des motifs complexes dans une chaîne de caractères. On écrit les motifs à rechercher grâce à plusieurs caractères spéciaux:
\begin{description}
	\item [Spécification du caractère]~
	      \begin{itemize}
		      \item \og\mintinline{text}{.}\fg{} désigne n'importe quel caractère.
		      \item \og\mintinline{text}{[]}\fg{} permet de dire quels caractères on veut trouver (\mintinline{text}{[a-e]} : \mintinline{text}{a}, \mintinline{text}{b}, \mintinline{text}{c}, \mintinline{text}{d} ou \mintinline{text}{e}; \mintinline{text}{[a-eA-E]} idem avec les majuscule comprises; \mintinline{text}{[+-*]}: soit \mintinline{text}{*} soit \mintinline{text}{+} soit \mintinline{text}{-}).
		      \item \og\Verb[fontsize=\small]|\w|\fg{} équivaut à \Verb[fontsize=\small]|[a-zA-Z0-9_]|.
		      \item \og\Verb[fontsize=\small]|\W|\fg{} désigne tout caractère non alpha-numérique.
		      \item \og\Verb[fontsize=\small]|\d|\fg{} équivaut à \mintinline{text}{[0-9]}.
		      \item \og\Verb[fontsize=\small]|\D|\fg{} désigne tout caractère non numérique.
		      \item \og\Verb[fontsize=\small]|\s|\fg{} désigne un espace.
	      \end{itemize}
	\item [Place du motif dans la chaine]~
	      \begin{itemize}
		      \item \og\Verb[fontsize=\small]!^!\fg{} (se place au début) signifie que le début de la chaine doit correspondre au motif.
		      \item \og\mintinline{text}{\$}\fg{} (se place à la fin) signifie que la fin de la chaine doit correspondre au motif.
	      \end{itemize}
	\item [Nombre d'apparition(s) consécutive(s)]~
	      \begin{itemize}
		      \item \og\mintinline{text}{\{n\}}\fg{} indique que le caractère précédent doit apparaitre \mintinline{text}{n} fois.
		      \item \og\mintinline{text}{\{n,m\}}\fg{} indique que le caractère précédent doit apparaitre entre \mintinline{text}{n} et \mintinline{text}{m} fois.
		      \item \og\mintinline{text}{*}\fg{} indique que le caractère précédent n'apparait pas ou apparait sans maximum d'occurences (\mintinline{text}{ab*} correspond à \mintinline{text}{a}, \mintinline{text}{ab}, ou bien \mintinline{text}{abbbbbb}, etc.).
		      \item \og\mintinline{text}{+}\fg{} indique que le caractère précédent apparait au moins une fois (\mintinline{text}{ab+} correspond à \mintinline{text}{ab}, \mintinline{text}{abb}, ou bien \mintinline{text}{abbbbbb}, etc.).
		      \item \og\mintinline{text}{?}\fg{} indique que le caractère précédent apparait au plus une fois (équivalent à \mintinline{text}{\{0,1\}}).
	      \end{itemize}
\end{description}

Les quatre derniers qualificateurs sont dits gourmands : ils valident autant de caractères que possible. Par exemple pour \mintinline{text}{"aaaaa"}, \mintinline{text}{a\{3,5\}} validera la chaine en entier. Pour une version non gourmande, on suit le qualificateur d'un \mintinline{text}{?} : \mintinline{text}{*?}, \mintinline{text}{+?}, \mintinline{text}{??} et \mintinline{text}{\{n,m\}?}. Un qualificateur non gourmand valide le moins de caractères possibles.\bigskip

Pour contrôler le nombre d'apparitions d'un groupe de caractères, on met ceux-ci entre parenthèses (\mintinline{text}{(abc)+}: \mintinline{text}{abc}, \mintinline{text}{abcabc}, etc.). Cela crée un groupe de caractères, on peut le nommer en suivant la parenthèses ouvrante de \mintinline{text}{?P<nom>}. Cela est utile par exemple quand on veut remplacer des caractères. On peut séparer des expression régulières par un \mintinline{text}{|} afin d'indiquer que plusieurs possibilités sont possibles.\bigskip

\subsection{Méthodes}
On compile une expression régulière en utilisant la fonction \mintinline{python3}{compile} \marginpar{\href{https://docs.python.org/fr/3/library/re.html\#re.compile}{\mintinline{python3}{re.compile}}}. Cette fonction retourne un objet expression régulière (un objet Pattern) sur lequel on peut évaluer diverses méthodes. Si l'on cherche une phrase, la syntaxe sera:

\begin{minted}{python3}
import re

regex = re.compile(r"[A-Z]\w*\s?(\w+\s?)*.")
\end{minted}

\paragraph{Remarque} On utilise le préfixe \mintinline{text}{r} devant la chaine de caractère pour éviter d'avoir à écrire \Verb[fontsize = \small]|\\| au lieu d'un unique \Verb[fontsize = \small]|\|.\bigskip

On peut rechercher toutes les occurences du motif grâce à la méthode \mintinline{python3}{re.finditer(motif, chaine)} \marginpar{\href{https://docs.python.org/fr/3/library/re.html\#re.Pattern.finditer}{\mintinline{python3}{Pattern.finditer}}}. Cela retourne un objet iterable. On accède aux objets en appelant \mintinline{python3}{next(iterable)}, qui retourne un objet expression rationnelle. Celui-ci contient plusieurs chaînes de caractères (une pour chaque groupe du motif), on y accède en appelant les différents groupes : \mintinline{python3}{objet.group(numéro ou nom)}.\bigskip

\paragraph{Exemple} On veut extraire les phrases d'une chaîne de caractères.
\begin{minted}{pycon}
>>> chaine = r"Je suis une phrase. Moi aussi"
>>> regex = re.compile(r"[A-Z]\w*\s?(?:\w+\s?)*.")
>>> resultats = regex.finditer(chaine)
>>> for phrase in resultats:
...     print(phrase.group(0))
...
Je suis une phrase.
Moi aussi.
\end{minted}

On peut remplacer les motifs par d'autres motifs en utilisant la méthode \mintinline{python3}{re.sub}\marginpar{\href{https://docs.python.org/fr/3/library/re.html\#re.Pattern.sub}{\mintinline{python3}{Pattern.sub}}}. Elle prend en paramètres:
\begin{enumerate}
	\item le motif (chaîne de caractères ou objet expression rationnelle.)
	\item le remplacement (peut être une fonction)
	\item la chaine à traiter
	\item \mintinline{python3}{count=}le nombre d'occurences à remplacer
\end{enumerate}
et renvoie la chaine de caractères modifiée. Lorsque l'on veut appeler un groupe de caractères nommé avec \mintinline{python3}{(?P<nom>)}, on y fait référence dans la chaine de remplacement par \Verb[fontsize = \small]|\g<nom>|.

% \paragraph{Exemple}
% \begin{minted}{python3}
% pass
% \end{minted}



\section{\texttt{datetime} --- Objets dates}\label{datetime}
\index{datetime}

Le module \mintinline{python3}{datetime}\marginpar{\mintinline{python3}{datetime}} permet de créer des objets représentant des dates et de faire des opérations. La classe \mintinline{python3}{datetime.date} représente une date par son année, son mois et son jour: \mintinline{python3}{jour = datetime.date(2017, 1, 1)} correspond à la date 1\ier{} janvier 2017.
La classe \mintinline{python3}{datetime.timedelta} permet de faire des opérations sur les dates. Ses objets sont représentés par un nombre de jours (on peut construire un \mintinline{python3}{timedelta} avec des semaines/mois/années, le constructeur convertit en jours).
Le module \mintinline{python3}{datetime} peut ausi être utilisé pour utiliser des durées plus réduites, i.e.\ secondes, minutes, heures, etc.

\paragraph{Exemple}
\begin{minted}{pycon}
>>> import datetime
>>> j1 = datetime.date(2017, 1, 1)
>>> j2 = j1 + datetime.timedelta(30)
>>> j2
datetime.date(2017, 1, 31)
\end{minted}


\paragraph*{Documentation} \href{https://docs.python.org/fr/3/library/datetime.html}{Documentation Python 3}

\section{\texttt{functools} --- Outils pour les fonctions}
Ce module fournit des outils pour la manipulation de fonctions

\subsection{Préservation de la signature d'une fonction décorée}
Décorer une fonction change sa signature:

\begin{minted}{pycon}
>>> def f():
...     return "Hello!"
...
>>> f()
"Hello!"
>>> f
<function f at 0x0000023CECFFC1E0>
>>> def deco(f):
...     def wrapper():
...         print(f())
...         print("Done.")
...     return wrapper
...
>>> @deco
... def f():
...     return "Hello!"
...
>>> f()
Hello!
Done.
>>> f
<function deco.<locals>.wrapper at 0x0000023CEDB2EF28>
\end{minted}

Le décorateur \mintinline{python3}{@wraps} du module \mintinline{python3}{functools} permet d'y remédier.
\begin{minted}{pycon}
>>> from functools import wraps
>>> def deco(f):
...     @wraps(f)
...     def wrapper(*args, **kwargs):
...         print(f())
...         print("Done.")
...     return wrapper
...
>>> @deco
... def f():
...     return "Hello!"
...
>>> f()
Hello!
Done.
>>> f
<function f at 0x00000223E312DEA0>
\end{minted}

\section{\texttt{turtle} --- Dessins basiques}
\index{turtle}

Contient des classes pour dessiner des formes simples en faisant avancer des tortues. Elles peuvent avancer, reculer, tourner d'un certain angle.
La classe \mintinline{python3}{Turtle} permet de créer des objets tortues qui peuvent :
\begin{enumerate}
	\item Avancer: \mintinline{python3}{Turtle.forward(<nb de pixels>)}
	\item Reculer: \mintinline{python3}{Turtle.backward(<nb de pixels>)}
	\item Tourner à droite ou à gauche (ex: \mintinline{python3}{Turtle.right(<degrés>)})
	\item Changer de couleur (\mintinline{python3}{Turtle.color(<couleur>)}) ou de forme (\mintinline{python3}{Turtle.shape(<forme>)}).
\end{enumerate}

\paragraph{Exemple}
\begin{minted}{python3}
import turtle

Terrain = turtle.Screen()
Terrain.bgcolor("black")

Tortue = turtle.Turtle()
Tortue.speed(3)
Tortue.shape("turtle")
Tortue.color("white")

for i in range(50):
    for e in range(4):
        Tortue.forward(100)
        Tortue.right(90)
    Tortue.right(360/50)

Terrain.exitonclick()
\end{minted}

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.5]{turtle.PNG}
		\caption*{Résultat}
	\end{center}
\end{figure}

\paragraph{Plus d'informations} \href{https://docs.python.org/fr/3.6/library/turtle.html#methods-specific-to-screen-not-inherited-from-turtlescreen}{Documentation Python 3}, \href{https://fr.wikibooks.org/wiki/Programmation_Python/Turtle}{Wikilivres}

\section{\texttt{ctypes} --- Appeler des fonctions en C}
\index{ctypes}
Ce module sert à appeler des fonctions écrites en langage C dans des librairies DLL par exemple.
\subsection{Boites de dialogue}
\index{boîte de dialogue}
Le module ctypes peut servir à faire apparaître des boites de dialogue. On peut modifier le comportement du script Python en fonction du bouton appuyé car la fonction faisant apparaître ces boites renvoie un entier qui dépend du bouton appuyé. Diverses options sont disponibles :
\begin{minted}{python3}
# Boutons disoponibles :
# 0 : OK
# 1 : OK | Annuler
# 2 : Abandonner | Recommencer | Ignorer
# 3 : Oui | Non | Annuler
# 4 : Oui | Non
# 5 : Recommencer | Annuler
# 6 : Annuler | Recommencer | Continuer

# Icone
# 16 Icone erreur
# 32 Icone question
# 48 Icone attention
# 64 Icone information
\end{minted}

\paragraph{Exemple}
\begin{minted}{python3}
ctypes.windll.user32.MessageBoxW(0, "That's an error", "Warning!", 16)
\end{minted}
\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.5]{errorwindow.png}
		\caption*{Résultat}
	\end{center}
\end{figure}

\section{\texttt{keyboard} --- Manipulation du clavier}\index{keyboard}

\section{\texttt{os} --- Diverses interfaces avec le systèle d'exploitation}\index{os}

\section{\texttt{sys} --- Fonctions et paramètres spécifiques au système}\index{sys}

\section{\texttt{threading} --- Programmation parallèle}\index{threading}

\section{\texttt{asyncio} --- Programmation asynchrone}\index{asyncio}

\paragraph{Nota Bene} Pour l'instant, cette section sort un peu de nulle part, mais tout s'éclaircira quand la syntaxe des \mintinline{python3}{async} et \mintinline{python3}{await} sera expliquée.\bigskip

Cette bibliothèque permet de facilement effectuer de la programmation asynchrone (à ne pas confondre avec la programmation en parallèle). L'intérêt est de rendre les tâches non-bloquantes, typiquement les requêtes à des serveurs qui peuvent mettre du temps à obtenir une réponse. Cette librairie n'est pas adaptée pour les calculs longs, car elle ne permet pas de calculer plus rapidement !\bigskip

\textbf{Exemple} Voici un code synchrone que l'on peut rendre asynchrone.
\begin{minted}{python3}
import time


def sync_get_response(id, temps_de_reponse):
    time.sleep(temps_de_reponse/1000)  # simulation temps de reponse
    print("Réponse {} reçue !".format(id))


def sync_main():
    sync_get_response(1, 50)
    sync_get_response(2, 50)
    sync_get_response(3, 4000)
    sync_get_response(4, 50)
    sync_get_response(5, 50)
    sync_get_response(6, 6000)
    sync_get_response(7, 50)
    sync_get_response(8, 50)
    sync_get_response(9, 50)

beginning = time.time()
sync_main()
print('Durée', time.time()-beginning)
\end{minted}

\begin{minted}{pycon}
Réponse 1 reçue !
Réponse 2 reçue !
Réponse 3 reçue !
Réponse 4 reçue !
Réponse 5 reçue !
Réponse 6 reçue !
Réponse 7 reçue !
Réponse 8 reçue !
Réponse 9 reçue !
Durée 10.367376565933228
\end{minted}
On remarque que les requêtes longues ralentissent l'exécution du programme. De plus, les requêtes sont effectuées dans l'ordre.


\begin{minted}{python3}
import asyncio
import time


async def get_response(id, temps_de_reponse)
    await asyncio.sleep(temps_de_reponse/1000)
    print("Réponse {} reçue !".format(id))


async def main():
    req1 = loop.create_task(get_response(1, 50))
    req2 = loop.create_task(get_response(2, 50))
    req3 = loop.create_task(get_response(3, 1000)) # simulons une requete longue
    req4 = loop.create_task(get_response(4, 50))
    req5 = loop.create_task(get_response(5, 50))
    req6 = loop.create_task(get_response(6, 1000)) # une autre
    req7 = loop.create_task(get_response(7, 50))
    req8 = loop.create_task(get_response(8, 50))
    req9 = loop.create_task(get_response(9, 50))
    await asyncio.wait([req1, req2, req3, req4, req5, req6, req7, req8, req9])

if __name__ == '__main__':
    beginning = time.time()
    try:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())
    except:
        pass
    finally:
        loop.close()
        print('Durée', time.time()-beginning)

\end{minted}
\begin{minted}{pycon}
Réponse 1 reçue !
Réponse 7 reçue !
Réponse 9 reçue !
Réponse 8 reçue !
Réponse 2 reçue !
Réponse 5 reçue !
Réponse 4 reçue !
Réponse 3 reçue !
Réponse 6 reçue !
Durée 5.994143724441528
# asyncio.sleep() resquillerait-il ? On lui a pourtant demandé de dormir 6 secondes !
\end{minted}
Dans le 2e exemple, le programme n'attend pas de recevoir la réponse pour envoyer les autres requêtes.

\part{Modules à télécharger}
\section{\texttt{virtualenv} --- Environnements virtuels}\label{virtualenv}\index{virtualenv}

Les environnement virtuels \marginpar{\href{https://pypi.org/project/virtualenv/}{\mintinline{python3}{virtualenv}}} sont un bon moyen pour:
\begin{enumerate}
	\item Installer des modules sans avoir besoin des droits administrateurs
	\item Avoir plusieurs environnements de travail avec des modules Python de versions différentes. Exemple, j'ai un projet Django 2 et je veux créer un site avec Django-CMS, qui requiert Django 1! Je suis obligé de recourir aux environnements virtuels.
\end{enumerate}

Pour une utilisation basique, on commence par installer \mintinline{python3}{virtualenv} avec \mintinline{python3}{pip}.

\begin{minted}{bash}
$ pip install virtualenv # ou pip3 selon votre version de Python
\end{minted}

Puis on se place dans le dossier où l'on veut placer les environnements virtuels, par exemple sous Linux dans \Verb[fontsize=\small]|/home/votre_nom/python_env/|, et on crée notre environnement!

\begin{minted}{bash}
$ virtualenv env
\end{minted}

Python y place alors les exécutables fondamentaux et quelques modules basiques. Ensuite, pour travailler dans l'environnement créé, il faut lancer la commande:
\begin{minted}{bash}
$ source /home/votre_nom/python_env/env/bin/activate
\end{minted}

L'environnement apparaît maintenant entre parenthèses dans la console. Pour désactiver cet environnement, on lance simplement la commande:

\begin{minted}{bash}
(env) $ deactivate
\end{minted}

Il existe le module \mintinline{python3}{virtualenvwrapper}\marginpar{\href{https://pypi.org/project/virtualenvwrapper/}{\mintinline{text}{virtualenvwrapper}}}\index{virtualenvwrapper} qui permet de naviguer facilement entre les environnements. Après avoir installé ce paquet, il faut ajouter dans le path une variable \mintinline{bash}{WORKON_HOME} qui correspond au répertoire où seront stockés les environnement virtuels. Ensuite on pourra utiliser les commandes

\begin{minted}{bash}
$ mkvirtualenv env # creation d'un environnement virtuel
$ workon # visualisation des environnements existants
env
(env) $ workon env # selection d'un environnement
(env) $ deactivate # quitter cet environnement
\end{minted}

\paragraph{Plus d'informations} \href{https://virtualenv.pypa.io/en/stable/}{Documentation de virtualenv}, \href{http://sametmax.com/les-environnement-virtuels-python-virtualenv-et-virtualenvwrapper/}{informations supplémentaires}


\section{\texttt{django} --- Framework Web Full Stack}\index{django}
Ce \marginpar{\href{https://pypi.org/project/Django/}{\mintinline{python3}{django}}} module permet de créer des sites web en Python. \emph{Il est question ici de la version 2}.
\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/}{Documentation officielle de Django 2.0} \href{https://docs.djangoproject.com/fr/2.0/intro/}{Tutoriel de la documentation}

\subsection{Fonctionnement}

Django fonctionne selon l'architecture Model-View-Template (MVT) que l'on peut traduire par Modèle-Vue-Gabarit. Celle-ci s’appuie sur l'architecture Model-View-Controler (MVC):
\begin{itemize}
	\item Les modèles structurent de la base de données, là où sont stockées toutes les informations. Ici, ce sont des classes Python dont les attributs correspondent à des champs dans la base de données. On n'écrit jamais de SQL avec Django!
	\item Les vues représentent les pages web: elles présentent les informations aux utilisateurs et récupèrent leurs actions. Ici, ce sont des fonctions Python qui prennent en argument la requête (HTTP par exemple) et des informations sur l’URL et qui renvoie, en utilisant les gabarits, la bonne page à l'utilisateur (la bonne réponse HTTP).
	\item Les gabarits permettent de structurer facilement les vues. Ce sont des fichiers HTML avec un peu de syntaxe de gabarit Django.
	\item Le contrôleur fait l'interface entre les vues et les modèles: il récupère et renvoie les informations nécessaires. Cette partie est gérée de manière autonome par Django.
\end{itemize}

\subsection{Didacticiel}
Cette partie s'appuie sur le tutoriel de la documentation Django, ne pas hésiter à s'y rendre pour plus d'infos. Concertant l'installation, il est conseillé d'installer Django dans un \hyperref[virtualenv]{environnement virtuel}. Dans cet environnement, on utilise l'installateur autonome \mintinline{python3}{pip}.

\begin{minted}{bash}
$ pip install Django
\end{minted}

\subsubsection{Créer un projet}
\begin{minted}{bash}
$ django-admin startproject nom_du_projet
\end{minted}

Un dossier est créé, avec trois sous-dossiers (un nommé d'après le projet, un dossier media, et un dossier static) et trois fichiers (une base de données, un fichier python et un fihcier requirements.txt). Pour lancer une première fois le projet sur un serveur local, on utilise la commande (il faut être dans le dossier du projet):
\begin{minted}{bash}
$ python manage.py runserver # on peut remplacer python par python3
\end{minted}
En se rendant sur l’URL indiquée, ou plus simplement \mintinline{python3}{localhost:8000} (on peut modifier le port si l'on veut: on écrit le port souhaité à la suite de la commande précédente), on tombe sur une page nous disant que l'installation de Django a réussi.

\subsubsection{Créer une application}
Une fois le projet créé, on crée une première application (cela peut être un sondage, un blog, etc., les applications sont les blocs du site). Une application peut être réutilisée pour d'autres projets. On crée une application par la commande (en étant dans le répertoire du projet) :
\begin{minted}{bash}
$ python manage.py startapp nom_de_l_application
\end{minted}

\subsubsection{Le fichier \mintinline{python3}{settings.py}}
Il comporte les principaux paramètres du projet. On y renseigne notamment le type de base de données que l'on utilise; si on utilise SQLite, tout est géré automatiquement. On y gère aussi le fuseau horaire, les langues, les applications installées, parmi les suivantes, installées par défaut:
\begin{itemize}
	\item \mintinline{python3}{django.contrib.admin}: l'interface d'administration
	\item \mintinline{python3}{django.contrib.auth}: un système d'authentification
	\item \mintinline{python3}{django.contrib.contenttypes}: une structure pour les types de contenu
	\item \mintinline{python3}{django.contrib.sessions}: un cadre pour les sessions
	\item \mintinline{python3}{django.contrib.messages}: un cadre pour l'envoi de messages
	\item \mintinline{python3}{django.contrib.staticfiles}: une structure pour la prise en charge des fichiers statiques
\end{itemize}

\subsubsection{Migrations}

Ces applications nécessitent des tables dans la base de données. Elles ne sont pas créées lors de la création du projet (d'où un probable message d'erreur lors du premier lancement), on crée les tables nécessaires grâce à la commande:
\begin{minted}{bash}
$ python manage.py migrate
\end{minted}

Il faut relancer cette commande lorsque l'on doit mettre à jour la base de données, typiquement lorsque l'on crée ou modifie des modèles, ou que l'on importe ou crée des applications.

\subsubsection{Structure des fichiers}
La structure des fichiers est la suivante, pour un projet appelé monsite et une application nommée monapplication.

\begin{minted}{text}
monsite/
    manage.py
    monsite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
    monapplication/
        __init__.py
        admin.py
        migrations/
            __init__.py
        models.py
        tests.py
        views.py
\end{minted}

On s'intéresse maintenant à cette application

\subsubsection{Ecrire une vue}
Les vues s'écrivent dans le fichier \mintinline{python3}{views.py}, ce sont des fonctions. On peut commencer par écrire une première vue basique:

\begin{minted}{python3}
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello world!")
\end{minted}

Cette fonction récupère une requette HTTP et renvoie une réponse HTTP. Celle-ci est écrite en HTML ici directement en argument de \mintinline{python3}{HttpResponse()}, en général on n'utilise pas cette façon de faire, on utilise les modèles et les gabarits.

\subsubsection{Lui associer une url}
Il faut associer à la vue que l'on vient de créer une URL, c'est-à-dire la requête associée. On crée donc un fichier \mintinline{python3}{urls.py} dans le répertoire de l'application:
\begin{minted}{python3}
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
\end{minted}

La page \og index \fg{} est par convention (je crois) la page affichée lorsque l'on appelle la racine du projet ou d'une application, c'est pour cela que le premier argument de la fonction \mintinline{python3}{path()} est une chaîne vide. Il faut maintenant relier les URL de l'application aux URL du projet, en modifiant \mintinline{python3}{urls.py} du répertoire racine du projet:

\begin{minted}{python3}
from django.contrib import admin
from django.urls import include
from django.urls import path

urlpatterns = [
    path('monapplication/', include('monapplication.urls')),
    path('admin/', admin.site.urls),
]
\end{minted}

La fonction \mintinline{python3}{include()} permet de faire appel aux autres fichiers d’URL que l'on a créés, il faut toujours utiliser cette fonction, la seule exception étant l'administration. On peut tester en lançant un \mintinline{python3}{runserver}. Si on va sur \mintinline{python3}{localhost:8000}, on a une erreur 404! En se rendant à l'URL \mintinline{python3}{localhost:8000/monapplication/ }, Hello world! apparaît.

\subsubsection{Créer un modèle}
Les modèles structurent la base de données et contiennent des métadonnées. Prenons un exemple musical et créons un modèle \mintinline{python3}{Artiste} et un modèle \mintinline{python3}{Chanson}. On les implémente en tant que classes dans le fichier \mintinline{python3}{models.py}:
\begin{minted}{python3}
from django.db import models

class Artiste(models.Model):
    nom = models.CharField(max_length=100)
    genre = models.CharField(max_length=100)
    bio = models.TextField(max_length=1000)

class Chanson(models.Model):
    titre = models.CharField(max_length=200)
    annee = models.DateTimeField('année de sortie')
    album = models.CharField(max_length=200)
    artiste = models.ForeignKey(Artiste, on_delete=models.CASCADE)
\end{minted}

Les champs sont représentés par des différentes instance de classe \mintinline{python3}{Field}, il en existe divers types. Le premier paramètre non nommé de ces instances permet sert à donner un nom plus lisible à ces champs (ici on l'a utilisé pour \mintinline{python3}{annee}).\bigskip

Une fois ces modèles créés, il faut les activer dans la base de données. Pour cela, il faut commencer par indiquer dans le fichier \mintinline{python3}{settings.py} que l'on a créé une nouvelle application. On ajoute dans \mintinline{python3}{INSTALLED\_APPS} une référence vers la classe de configuration de l'application (qui se trouve dans le fichier \mintinline{python3}{apps.py}). On se trouve donc avec, dans \mintinline{python3}{settings.py}:

\begin{minted}{python3}
INSTALLED_APPS = [
    'monapplication.apps.MonapplicationConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
\end{minted}

On indique alors à Django que les modèles ont été modifiés:
\begin{minted}{bash}
$ python manage.py makemigrations monapplication # on n'est pas obligé de mettre le nom de
                                                 # l'application
\end{minted}

Cette instruction est l'analogue d'un \mintinline{python3}{git stage}, il faut exécuter ensuite la méthode \mintinline{python3}{migrate} pour appliquer les migrations (analogue à \mintinline{python3}{git commit}).

\begin{minted}{bash}
$ python manage.py migrate
\end{minted}

\paragraph{Remarque} Les deux étapes précédentes sont à répéter à chaque fois que l'on a modifié les modèles.

\subsubsection{Interface administrateur}
Il y a deux manières d'interagir avec la base de données:
\begin{enumerate}
	\item Avec l'\href{https://docs.djangoproject.com/fr/2.0/topics/db/queries/}{API Django} (non développé ici) à travers le shell Python.
	\item Avec l'interface graphique administrateur de Django.
\end{enumerate}

L'interface administrateur est créée automatiquement. Pour y accéder, il faut commencer par créer un super-utilisateur.

\begin{minted}{bash}
$ python manage.py createsuperuser
\end{minted}

Il suffit ensuite de suivre la procédure. Une fois cela fini, on peut se rendre (après un \mintinline{python3}{runserver}) sur l'interface à l'adresse \mintinline{python3}{localhost:8000/admin}. Une page de connexion apparaît, on se connecte avec les identifiants du compte super-utilisateur créé précédemment. Après connexion, on arrive sur la page d'administration. Cependant, nous n'avons toujours pas accès aux modèles que l'on a créés. Pour cela, il faut modifier le fichier \mintinline{python3}{admin.py} de l'application:
\begin{minted}{python3}
from django.contrib import admin
from .models import Chanson
from .models import Artiste

admin.site.register(Artiste)
admin.site.register(Chanson)
\end{minted}
Ainsi, les modèles apparaissent dans un bloc correspondant à l'application concernée (\hyperref[admin2]{figure 1}). On peut donc créer une chanson, par exemple (\hyperref[admin3]{figure 2}). On voit que l'on peut renseigner tous les champs que l'on a créés dans nos modèles. L'outil d’administration est donc un outil très puissant qui nous permet d'agir sur la base de données graphiquement!
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=15 cm]{django/admin2.jpg}
		\caption{Administration avec les modèles créés}\label{admin2}
	\end{center}
\end{figure}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=15 cm]{django/admin3.jpg}
		\caption{Créer une chanson}\label{admin3}
	\end{center}
\end{figure}

Si l'on crée une chanson ou un artiste, on peut voir que dans la liste des objets, apparaît la mention "Chanson object" ou bien "Artiste object". En effet, on n'a pas défini de méthode de représentation dans nos modèles, on peut le faire comme suit:
\begin{minted}{python3}
from django.db import models

class Artiste(models.Model):
    nom = models.CharField(max_length=100)
    genre = models.CharField(max_length=100)
    bio = models.TextField(max_length=1000)

    def __str__(self):
        return self.nom

class Chanson(models.Model):
    titre = models.CharField(max_length=200)
    annee = models.DateTimeField('année de sortie')
    album = models.CharField(max_length=200)
    artiste = models.ForeignKey(Artiste, on_delete=models.CASCADE)

    def __str__(self):
        return self.titre
\end{minted}

En actualisant la page, les noms des artistes et titres de chansons apparaissent bien.

\subsubsection{Introduction aux vues et gabarits}
Créons plus de vues dans le fichier \mintinline{python3}{views.py}. Par exemple des vues qui affichent des artistes et leurs chansons, des vues qui affichent des chansons et leurs paroles. On commence simplement:

\begin{minted}{python3}
def artiste(request, artiste_id):
    return HttpResponse("Vous êtes sur la page de l'artiste {}".format(artiste_id))

def chanson(request, chanson_id):
    return HttpResponse("Vous êtes sur la page de la chanson {}".format(chanson_id))
\end{minted}

Il faut ensuite aller renseigner les URL dans \mintinline{python3}{urls.py}
\begin{minted}{python3}
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index),
    path('chanson/<chanson_id>/', views.chanson),
    path('artiste/<artiste_id>/', views.artiste)
]
\end{minted}

Si on va sur la page \mintinline{python3}{localhost:8000/monapplication/artiste/1}, on voit : \og Vous êtes sur la page de l'artiste 1\fg{}. En effet, Django analyse l'URL de la manière suivante:
\begin{enumerate}
	\item \mintinline{python3}{monapplication/} il va dans les URL de l’application monapplication
	\item \mintinline{python3}{artiste/1/} il cherche la ligne correspondante dans le fichier \mintinline{python3}{urls.py}. Il trouve alors la ligne\\ \Verb[fontsize=\small]|artiste/<artiste_id>|, il appelle donc la vue\\ \Verb[fontsize=\small]|artiste(request=<HttpRequest object>, question_id=1)|.
\end{enumerate}

On peut aussi créer des vues qui interagissent avec la base de données en utilisant l'\href{https://docs.djangoproject.com/fr/2.0/topics/db/queries/}{API Django}. Par exemple les pages racines d'artistes et de chansons pourraient les afficher dans l'ordre alphabétique. On aura finalement le fichier \mintinline{python3}{views.py} suivant.

\begin{minted}{python3}
from django import HttpResponse
from django.shortcuts import render
from .models import Artiste
from .models import Chanson


def index(request):
    return HttpResponse("Hello world!")


def liste_chanson(request):
    liste_chansons = Chanson.objects.order_by('nom')
    context = {
        "liste_chansons": liste_chansons
    }
    return render(request, '/monapplication/chansons/index.html', context)


def liste_artiste(request):
    liste_artistes = Artiste.objects.order_by('nom')
    context = {
        "liste_artistes": liste_artistes
    }
    return render(request, '/monapplication/artistes/index.html', context)


def artiste(request, artiste_id):
    return HttpResponse("Vous êtes sur la page de l'artiste {}"
                        .format(artiste_id))


def chanson(request, chanson_id):
    return HttpResponse("Vous êtes sur la page de la chanson {}"
                        .format(chanson_id))

\end{minted}

On va utiliser des gabarits pour les deux premières vues. La fonction \mintinline{python3}{render()} est un raccourci qui permet de renvoyer une réponse HTTP avec un gabarit. Les gabarits sont des fichiers HTML rangés dans le répertoire \mintinline{python3}{templates} de l'application. Par exemple pour la liste d'artistes, on aura
\begin{minted}{bash}
monapplication/templates/monapplication/artistes/index.html
\end{minted}

Voici un simple gabarit pour la liste des artistes:
\begin{minted}{html}
{% if liste_artistes %}
    <ul>
    {% for artiste in liste_artistes %}
        <li><a href="/monapp/artiste/{{ artiste.id }}/">{{ artiste.nom }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>Aucun artiste.</p>
{% endif %}
\end{minted}

\paragraph{Remarque} Même si dans nos modèles, on ne crée pas d'attribut \mintinline{python3}{id}, celui-ci est créé automatiquement.\bigskip

Il ne faut pas oublier de mettre à jour \mintinline{python3}{urls.py}:
\begin{minted}{python3}
urlpatterns = [
    path('', views.index),
    path('chanson/', views.liste_chanson),
    path('artiste/', views.liste_artiste),
    path('chanson/<chanson_id>/', views.chanson),
    path('artiste/<artiste_id>/', views.artiste)
]
\end{minted}

Ainsi, si vous allez sur \mintinline{python3}{localhost:8000/artiste/}, la liste de vos artistes s'affichera, ou bien \og Aucun artiste. \fg{} sinon.

\subsubsection{Fichiers statiques}

Les fichiers statiques sont rangés dans un répertoire nommé \mintinline{python3}{static}, l'architecture est similaire à celle des gabarits. Imaginons que l'on veuille tout mettre en vert. On crée un fichier \mintinline{python3}{style.css} dans le répertoire assoicé à l'application.

\begin{minted}{css}
html {
    color: green;
}
\end{minted}

On modifie ensuite par exemple le gabarit de la liste des artistes en ajoutant ce code au début:
\begin{minted}{html}
{% load static %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}" />
\end{minted}

La balise de gabarit \Verb[fontsize=\small]|{% load static %}| génère l'URL absolue des fichiers statiques. Si on se rend à la page des artistes, tout est vert !

\subsubsection{Thèmes abordés ici}

Cela marque la fin du didacticiel. On s'intéresse maintenant aux différents aspects de Django:
\begin{enumerate}
	\item Les modèles
	\item Les vues
	\item Les gabarits
	\item Les formulaires
	\item L'administration
	\item Le déploiement
\end{enumerate}

Ce n'est pas exhaustif, la meilleure façon de se documenter reste la documentation officielle (qui est d'ailleurs très bien faite).

\subsection{Les modèles et les opérations sur la base de données}

Comme \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/}{\mintinline{python3}{django.db.models}}} indiqué dans le didacticiel:
\begin{enumerate}
	\item Les modèles sont des classes filles de \mintinline{python3}{models.Model} que l'on écrit dans le fichier \mintinline{python3}{models.py} de l'application concernée.
	\item Cette application doit être mentionnée dans la liste \mintinline{python3}{INSTALLED\_APPS} du fichier \mintinline{python3}{settings.py}
	\item Un modèle correspond à une table de la base de données. Les champs sont les attributs de la classe du modèle.
\end{enumerate}

\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/topics/db/}{Documentation Django 2 --- Portail thématique sur les modèles}

\subsubsection{Les champs: attributs des modèles}

Un champ \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/fields/\#field-types}{\mintinline{python3}{models.Field}}} de modèle doit être une instance de la classe \mintinline{python3}{Field} (où l'une de ses dérivées). Le choix du type de champ détermine le genre de donnée à stocker (par exemple des nombres ou du texte), le composants HTML qui sera utilisé dans le formulaire utilisé pour renseigner ce champs dans l'administration, et enfin les exigences minimales de validation de ce champ. Se référer aux liens dans la marge pour une documentation complète. Quelques types de champs génériques:
\begin{description}
	\item[\mintinline{python3}{class CharField(max_length=None, **options)}]~

	      Un champ pour une chaîne de caractère (courte ou longue). Le paramètre \mintinline{python3}{max\_length} règle la taille maximale de ce champ. Il en existe de plus précis pour les mails ou les URL, cf. la doc.

	\item[\mintinline{python3}{class DateField(auto_now=False, auto_now_add=False, **options)}]~

	      Une date, représentée par la classe Python \hyperref[datetime]{\mintinline{python3}{datetime.date}}. Le paramètre \mintinline{python3}{auto\_now} permet d'assigner automatiquement la date du jour à chaque enregistrement de l'objet, tandis que \mintinline{python3}{auto\_now\_add} enregistre la date du jour à la création de l'objet.

	\item[\mintinline{python3}{class DateTimeField(auto_now=False, auto_now_add=False, **options)}]~

	      Une heure, représentée par la classe Python \mintinline{python3}{datetime.datetime}

	\item[\mintinline{python3}{class IntegerField(**options)}]~

	      Un nombre entier compris entre -2147483648 et 2147483647.

	\item[\mintinline{python3}{class TextField(**options)}]~

	      Un champ de texte, plus adapté que \mintinline{python3}{CharField} pour les longs textes, car la zone de saisie est plus importante dans le formulaire (on ne détaille pas ici les composants HTML de formulaires, cf. la doc)
\end{description}

\subsubsection{Les relations entre les modèles}

On \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/fields/\#module-django.db.models.fields.related}{\mintinline{python3}{models.ForeignKey}}} peut aussi renseigner les relations entre les modèles (donc entre les tables de la base de données).
\begin{description}
	\item[\mintinline{python3}{class ForeignKey(to, on_delete, **options)}]~

	      Une relation plusieurs-à-un, (cf. le didacticiel, exemple des chansons qui ont l'artiste en \mintinline{python3}{ForeignKey}). Cette classe exige la classe à laquelle le modèle et relié, et l'option \mintinline{python3}{on\_delete}: \mintinline{python3}{models.CASCADE} si l'on veut que lorsque l'on supprime la \mintinline{python3}{ForeignKey}, que tous les objets associés du modèle concerné soient supprimés, ou bien \mintinline{python3}{SET\_NULL} si l'on veut que les objets aient la valeur \mintinline{python3}{null} à la place de la \mintinline{python3}{ForeignKey} supprimée (dans ce cas il faut aussi renseigner \mintinline{python3}{null=True}). Il y a d'autres possibilités (cf. la doc), \href{https://docs.djangoproject.com/fr/2.0/topics/db/examples/many_to_one/}{voir des exemples}.

	\item[\mintinline{python3}{class OneToOneField(to, on_delete, parent_link=False, **options)}]~

	      Une relation un-à-un, dont le fonctionnement est similaire à \mintinline{python3}{ForeignKey}; \href{https://docs.djangoproject.com/fr/2.0/topics/db/examples/one_to_one/}{voir des exemples}.

	\item[\mintinline{python3}{class ManyToManyField(to, **options)}]~

	      Une relation plusieurs-à-plusieurs, qui fonctionne de la même manière que \mintinline{python3}{ForeignKey} (avec d'autres paramètres supplémentaires, cf. la doc); \href{https://docs.djangoproject.com/fr/2.0/topics/db/examples/many_to_many/}{voir des exemples}.
\end{description}

\subsubsection{Les options des champs}
Les champs acceptent des \mintinline{python3}{options}\marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/fields/\#field-options}{\mintinline{python3}{**options}}}, en voici quelques unes (on note après un signe \mintinline{python3}{=} la valeur par défaut):
\begin{description}
	\item[\mintinline{python3}{null=False}]~

	      Si la valeur est \mintinline{python3}{True}, alors Django stocke les valeurs vides dans la base de données avec \mintinline{python3}{NULL}.

	\item[\mintinline{python3}{blank=False}]~

	      Si la valeur est \mintinline{python3}{True}, alors on peut laisser ce champ vide (cette option agit lors de la validation, ne pas confondre avec le paramètre précédent).

	\item[\mintinline{python3}{choices}]~

	      C'est un itérable (tuple ou liste par exemple) constitué de couples \mintinline{python3}{(A, B)} où \mintinline{python3}{A} est la valeur réelle pour le modèle et \mintinline{python3}{B} le texte affiché à l'utilisateur. On peut organiser en sous groupe comme dans cet exemple:

	      \begin{minted}{python3}
choix_media = [
    ['Audio', [('vinyl', 'Vinyl'), ('cd', 'CD')]],
    ['Vidéo', [('vhs', 'Cassette VHS'), ('dvd', 'DVD')]],
    ('unknown', 'Unknown'),
]
    \end{minted}

	\item[\mintinline{python3}{default}]~

	      C'est la valeur par défaut du champ, cela peut être un objet ou un objet appelable (dans ce cas, il est appelé lors de la création de l'objet). Il ne peut pas s'agir d'un objet muable! En effet, le système de noms de Python ferait que plusieurs instances de modèles seraient référencés vers une même instance de cet objet. Au lieu de cela, on crée une fonction qui retourne cet objet muable.

	\item[\mintinline{python3}{help_text}]~

	      C'est une chaîne de caractère qui décrit le champ concerné, utilise lorsque l'on utilise la documentation générée automatiquement par Django.

	\item[\mintinline{python3}{primary_key}]~

	      Si la valeur est \mintinline{python3}{True}, alors ce champ représentera une clé primaire du modèle. Si aucun champ n'est renseigné, Django en crée un automatiquement: \mintinline{python3}{id}.

	\item[\mintinline{python3}{verbose_name}]~

	      Chaîne de caractère qui est le \og nom verbeux \fg{} de l'attribut, c'est-à-dire un nom humainement compréhensible pour cet attribut. Il sera affiché à la place du nom de l'attribut dans le formulaire de l'administration (Django l'utilise en convertissant les soulignés en espaces). A l'exception des champs de relations, ce nom verbeux peut-être renseigné en tant que premier paramètre non nommé du champ. Pour ces exceptions, on doit nommer cette option.
\end{description}

\subsubsection{Les métadonnées}
On \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/options/}{\mintinline{python3}{Meta}}} peut attribuer des métadonnées à un modèle grâce à une classe \mintinline{python3}{Meta} incorporée dans la classe du modèle. C'est une classe facultative. Elle permet d'enrichir l'interface administrateur. On y renseigne plusieurs options, en voici quelques unes:
\begin{description}
	\item[\mintinline{python3}{ordering="-order_date"}]~

	      Définit une méthode de tri des instances d'un modèle. C'est une liste ou un tuple de chaîne de caractères. Chaque chaîne correspond à un nom de champ, préfixé par un \mintinline{python3}{-} si l'on veut que le tri soit descendant (on ne met rien pour un tri ascendant). Les tris sont rangés dans la liste par ordre de priorité (Django trie par rapport au premier critère, puis second, etc.)

	\item[\mintinline{python3}{verbose_name}, \mintinline{python3}{verbose_name_plural}]~

	      Noms verbeux (même principe que pour les champs) respectivement dans le cas du singulier et dans le cas du pluriel.

	\item[\mintinline{python3}{db_table}]~

	      Nom de la table dans la base de données. Par défaut, Django la nomme \mintinline{python3}{application\_modèle}.
\end{description}

\subsubsection{Les gestionnaires}
Le gestionnaire \marginpar{\href{https://docs.djangoproject.com/fr/2.0/topics/db/managers/}{\mintinline{python3}{models}}\par\quad\href{https://docs.djangoproject.com/fr/2.0/topics/db/managers/}{\mintinline{python3}{.manager}}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/topics/db/managers/}{\mintinline{python3}{.Manager}}} est l'interface par laquelle on fait des requêtes à la base de données avec l'\href{https://docs.djangoproject.com/fr/2.0/topics/db/queries/}{API Django} (voir le didacticiel pour un exemple, dans les vues \mintinline{python3}{liste\_artistes} ou \mintinline{python3}{liste\_chansons}. Le gestionnaire permet aussi bien d'inspecter la base de données que de la modifier.

\begin{description}
	\item[\mintinline{python3}{class Manager}]~

	      Gestionnaire de la classe concernée. Par défaut, on a (on ne l'écrit pas mais c'est comme-ci):
	      \begin{minted}{python3}
class Modèle:
    # ...
    objects = models.Manager()
    \end{minted}

	      On peut définir un gestionnaire personnalisé (par exemple pour une classe \mintinline{python3}{Personne}, on peut le nommer \mintinline{python3}{personnes}), dans ce cas, \mintinline{python3}{Modèle.objects} produira une exception \mintinline{python3}{AttributeError}. Si l'on veut définir un gestionnaire avec des méthodes personnalisées, il suffit de créer une classe héritant de \mintinline{python3}{Manager}.
\end{description}

\subsubsection{Modifier la base de données}
L'administration \marginpar{\mintinline{python3}{models}\par\quad\mintinline{python3}{.base}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/ref/models/instances/}{\mintinline{python3}{.Model}}} permet de facilement modifier la base de données à la main, mais on doit utiliser l'API Django si on veut modifier la base de données à partir des vues ou des modèles eux-mêmes (par exemple, en reprenant l'exemple du didacticiel, on peut imaginer que la sauvegarde d'un objet Chanson dans la base de données entraînera la création et sauvegarde de l'objet Artiste associé s'il n'existe pas).\bigskip

Pour insérer un objet dans la table de données, on commence déjà par l'instancier. Comme indiqué dans le didacticiel, tous les modèles héritent de la classe \mintinline{python3}{Model}.

\begin{description}
	\item[\mintinline{python3}{class Model}]~

	      Tous les modèles doivent hériter de cette classe! Ainsi on a accès à toutes les méthodes définies par défaut. Il est déconseillé de surcharger l'initialiseur \mintinline{python3}{__init__()}, car cela pourrait entraîner des erreurs. Il est conseillé de créer un gestionnaire personnalisé (une classe qui hérite de \mintinline{python3}{Manager}) et d'y écrire la méthode personnalisée.
\end{description}

Une fois les objets créés, on peut modifier leurs attributs (donc leurs futurs champs). Pour les inclure dans la base de données, il faut les sauvegarder. La première étape consiste à valider l'instance.

\begin{description}
	\item[\mintinline{python3}{Model.clean_fields(self, exclude=None)}]~

	      Cette méthode valide les champs de l'instance (typiquement, lève une erreur si un champ est vide, alors qu'on n'a pas le paramètre \mintinline{python3}{blank=True}). L'option \mintinline{python3}{exclude} permet d'indiquer des champs à ignorer lors de la validation. Si la validation échoue, lève une exception \mintinline{python3}{ValidationError}.

	\item[\mintinline{python3}{Model.clean(self)}]~

	      Une méthode à personnaliser pour effectuer des méthodes personnalisées sur notre modèle (effectuer automatiquement des valeurs à des champs, effectuer des validations qui demandent de vérifier plusieurs champs simultanément par exemple). Devrait lever une exception \mintinline{python3}{ValidationError} si échoue.

	\item[\mintinline{python3}{Model.validate_unique(self, exclude=None)}]~

	      Vérifie les contraintes d'unicité du modèle et lève une \mintinline{python3}{ValidationError} si échoue.

	\item[\mintinline{python3}{Model.full_clean(self, exclude=None, validate_unique=True)}]~

	      Exécute les trois méthodes précédentes (exécute \mintinline{python3}{validate\_unique} si le paramètre correspondant est \mintinline{python3}{True}).
\end{description}

\subsubsection{Récupérer des informations de la base de données}
Lorsque \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/}{\mintinline{python3}{models}}\par\quad\href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/}{\mintinline{python3}{.query}}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/}{\mintinline{python3}{.QuerySet}}} l'on veut récupérer des informations de la base de données, on utilise l'API Django. Différentes méthodes appliquées sur les gestionnaires des modèles permettent d'obtenir des objets \mintinline{python3}{QuerySet} qui contiennent les informations désirées. En résumé, on utilise la syntaxe:
\begin{minted}{python3}
# schéma
query_set = Modèle.gestionnaire.methode()
# exemple
liste_artistes = Artiste.objects.all() #  objects est le nom par défaut du gestionnaire
# on peut aussi appeler ces méthodes sur des QuerySet
liste_artistes_inversee = liste_artistes.reverse()
\end{minted}
Voici quelques méthodes qui renvoient un \mintinline{python3}{QuerySet}:

\begin{description}
	\item[\mintinline{python3}{gestionnaire.all()}]~

	      Renvoie un \mintinline{python3}{QuerySet} contenant toutes les entrées de la table.

	\item[\mintinline{python3}{gestionnaire.filter(**kwargs)}]~

	      Renvoie un \mintinline{python3}{QuerySet} contenant tous les objets répondant aux \href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/#field-lookups}{paramètres rentrés}.

	\item[\mintinline{python3}{gestionnaire.exclude(**kwargs)}]~

	      Renvoie un \mintinline{python3}{QuerySet} contenant tous les objets sauf ceux répondant aux \href{https://docs.djangoproject.com/fr/2.0/ref/models/querysets/#field-lookups}{paramètres rentrés}.

	\item[\mintinline{python3}{gestionnaire.reverse(**kwargs)}]~

	      Renvoie le \mintinline{python3}{QuerySet} dans l'ordre inverse.

	\item[\mintinline{python3}{gestionnaire.distinct(**kwargs)}]~

	      Renvoie un \mintinline{python3}{QuerySet} sans doublon.
\end{description}

Il y a plusieurs façons d'exploiter un \mintinline{python3}{QuerySet}:
\begin{itemize}
	\item Ils sont itérables:
	      \begin{minted}{python3}
# On imagine qu'on a déjà un QuerySet, on reprend le modèle du didacticiel
>>> liste_artistes
<QuerySet [<Artiste: Muse>, <Artiste: Keane>, <Artiste: Imagine Dragons>]>
>>> for artiste in liste_artistes:
...    print(artiste.nom)
...
Muse
Keane
Imagine Dragons
    \end{minted}

	\item On peut facilement récupérer le nombre d'éléments
	      \begin{minted}{python3}
>>> len(liste_artistes)
3
    \end{minted}

	\item On peut convertir le \mintinline{python3}{QuerySet} en liste:
	      \begin{minted}{python3}
>>> L = list(liste_artistes)
>>> L
[<Artiste: Muse>, <Artiste: Keane>, <Artiste: Imagine Dragons]
    \end{minted}

	\item Il existe des méthodes qui évaluent un \mintinline{python3}{QuerySet} et qui renvoient autre chose qu'un \mintinline{python3}{QuerySet}. En voici quelques unes.

	      \begin{description}
		      \item[\mintinline{python3}{query_set.get(**kwargs)}]~

		            Renvoie \emph{l'unique} objet répondant aux paramètres rentrés. S'il existe plusieurs objets possibles, ou zéro objet possible, cette fonction renvoie une erreur (respectivement \mintinline{python3}{MultipleObjectsReturned} et \mintinline{python3}{DoesNotExist}). Si une requête renvoie un \mintinline{python3}{QuerySet} singleton, on peut directement récupérer l'objet avec cette méthode sans paramètre (c'est risqué).

		      \item[\mintinline{python3}{query_set.get_or_create(defaults=None, **kwargs)}]~

		            Même comportement que ci-dessus, sauf que si l'objet n'existe pas, il est créé. Renvoie un tuple \mintinline{python3}{objet, créé} où \mintinline{python3}{objet} est l'objet créé ou charge, \mintinline{python3}{créé} un booléen: \mintinline{python3}{True} si l'objet a été créé et \mintinline{python3}{False} sinon. Cette méthode permet d'alléger la syntaxe et d'éviter d'avoir recours à \mintinline{python3}{try: ... except: ...}. Les méthodes permettant d'agir sur la base de données sont détaillées plus loin.

		      \item[\mintinline{python3}{query_set.update_or_create(defaults=None, **kwargs)}]~

		            Essaie de trouver un objet correspondant aux paramètres et lui assigne les nouvelles valeurs rentrées, et crée l'objet s'il n'existe pas. Renvoie la même chose que la méthode précédente.

		      \item[\mintinline{python3}{query_set.last()}]~

		            Renvoie le dernier objet d'un \mintinline{python3}{QuerySet} (si ce dernier n'est pas trié, il est automatiquement trié selon la clé primaire).

		      \item[\mintinline{python3}{query_set.first()}]~

		            Idem que la méthode précédente mais renvoie le premier objet.

		      \item[\mintinline{python3}{query_set.latest(*fields)}]~

		            Renvoie l'objet le plus récent selon le champ indiqué (on les indique de la même manière que pour \mintinline{python3}{ordering}).

		      \item[\mintinline{python3}{query_set.earliest(*fields)}]~

		            Idem que la méthode précédente mais renvoie le plus ancien.

	      \end{description}
\end{itemize}

\subsection{Les requêtes HTTP: vues et URL}
Comme \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/request-response/}{\mintinline{python3}{django.http}}}indiqué dans le didacticiel:
\begin{enumerate}
	\item Les vues sont des fonctions, rangées dans le fichier \mintinline{python3}{views.py} de l'application.
	\item Elles prennent en paramètre obligatoirement une requête Web (à laquelle peuvent s'ajouter des paramètres facultatifs) et renvoient une réponse Web.
	\item La gestion des URL associées aux vues se fait dans le fichier \mintinline{python3}{urls.py}.
\end{enumerate}

\paragraph{Plus d'informations} Documentation Django 2 --- \href{https://docs.djangoproject.com/fr/2.0/topics/http/views/}{Ecriture des vues} ---  \href{https://docs.djangoproject.com/fr/2.0/topics/http/urls/}{Distribution des URL}

\subsubsection{Requêtes HTTP}
Les \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/request-response/\#httprequest-objects}{\mintinline{python3}{http.HttpRequest}}} vues manipulent des requêtes HTTP et renvoient une réponse HTTP en utilisant les modèles et les gabarits. Elles prennent en paramètres une requête HTTP et d'éventuels paramètres supplémentaires dans l'URL (cf. le didacticiel). On commence par décrire ce qu'est une requête HTTP pour Django.

\begin{description}
	\item[\mintinline{python3}{class HttpRequest}]~

	      Lorsque Django reçoit une requête HTTP, il crée une instance de cette classe contenant les métadonnées associées à la requête. Elle est ensuite mise en premier paramètre de la vue appropriée (ce paramètre est par convention nommé \mintinline{python3}{request}, cf. les exemples dans le didacticiel). Cette classe présente plusieurs attributs et méthodes (voir la doc).
\end{description}

\subsubsection{Réponse HTTP}
On \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/request-response/\#httpresponse-objects}{\mintinline{python3}{http.HttpResponse}}} s'intéresse maintenant à ce que les vues renvoient: les réponses HTTP.

\begin{description}
	\item[\mintinline{python3}{class HttpResponse}]~

	      Cette classe hérite de \mintinline{python3}{HttpResponseBase}. Les réponses HTTP ne sont pas créées automatiquement par Django, ce sont les vues qui les créent. \emph{Une vue se doit de retourner une réponse HTTP!} Typiquement, on peut créer une réponse HTTP avec comme unique paramètre une chaîne de caractère qui sera le contenu de la page HTML retournée.

	      \begin{minted}{python3}
response = HttpResponse("Voici du texte de page Web.")
    \end{minted}

	      Quelques attributs:

	      \begin{description}
		      \item[\mintinline{python3}{HttpResponse.content}]~

		            Une chaîne de caractères qui représente le contenu de la réponse.

		      \item[\mintinline{python3}{HttpResponse.status_code}]~

		            Code HTTP de la réponse, 200 par défaut (succès de la réponse). Des classes filles de \mintinline{python3}{HttpResponse} ont une valeur par défaut différente.
	      \end{description}

	      Il existe aussi diverses méthodes (cf. la doc).

	\item[\mintinline{python3}{class HttpResponseNotFound(HttpResponse)}]~

	      Exemple de classe fille de \mintinline{python3}{HttpResponse}, identique à sa classe mère à l'exception de son code HTTP, ici, 404. Il en existe d'autres (voir la doc).
\end{description}

Comme \marginpar{\href{https://docs.djangoproject.com/fr/2.0/topics/http/shortcuts/\#render}{\mintinline{python3}{django}}\par\quad\href{https://docs.djangoproject.com/fr/2.0/topics/http/shortcuts/\#render}{\mintinline{python3}{.shortcuts}}\par\quad\quad\href{https://docs.djangoproject.com/fr/2.0/topics/http/shortcuts/\#render}{\mintinline{python3}{.render}}} premier paramètre (c'est-à-dire \mintinline{python3}{content}), on peut utiliser une méthode de gabarit, la méthode \mintinline{python3}{render}, qui permet de renvoyer du HTML en utilisant les gabarits. Il existe le raccourci \mintinline{python3}{render} pour alléger le code:

\begin{description}
	\item[\mintinline{python3}{render(request, template_name, context=None, content_type=None, status=None, using=None)}]~

	      Fonction qui combine un gabarit avec dictionnaire de contexte et renvoie une \mintinline{python3}{HttpResponse} avec le texte résultant. Deux paramètres obligatoires: \mintinline{python3}{request} et \mintinline{python3}{template\_name}, le nom complet du gabarit à utiliser.
\end{description}

Les deux vues suivantes sont équivalentes (issus de la doc
Django):
\begin{minted}{python3}
from django.shortcuts import render
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
\end{minted}

\begin{minted}{python3}
from django.http import HttpResponse
from django.template import loader
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
\end{minted}


\subsubsection{La gestion des URL}
Les URL \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/urls/}{\mintinline{python3}{django.urls}}} (Uniforme Resource Locators) sont gérés dans les différents fichiers \mintinline{python3}{urls.py}. Il y en a un dans chaque application et un dans le répertoire racine. Les URL sont configurées dans la liste \mintinline{python3}{urlpatterns}. Voici les principales fonctions à utiliser.

\begin{description}
	\item[\mintinline{python3}{path(route, view, kwargs=None, name=None)}]~

	      Cette fonction est utilisée dans la liste \mintinline{python3}{urlpatterns}. Elle prend deux paramètres obligatoires: la route, une chaîne de caractère qui correspond à une URL, et une vue (ou bien la fonction \mintinline{python3}{include} qui appelle d'autres URL). La route peut contenir des éléments entre chevrons \mintinline{python3}{<paramètre>} qui servent de paramètres pour la vue (rappel: les vues sont des fonctions).

	\item[\mintinline{python3}{include(module, namespace=None)}]~

	      Cette fonction, en général utilisée comme second paramètre de la fonction \mintinline{python3}{path()} prend en argument un module d'URL qu'il faut inclure après l'URL mise en premier paramètre.
\end{description}


\subsection{Les gabarits}
Un gabarit Django est un fichier texte ou une chaîne de caractères Python balisée en utilisant le langage de gabarit Django. Certaines expressions (étiquettes et variables) sont reconnues et inerprétées par le moteur de gabarit. Pour rendre un gabarit, celui-ci a besoin d'un dictionnaire de contexte: il remplace les variables par leur valeur et exécute les étiquettes. Le reste est maintenu tel quel.

\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/topics/templates/}{Documentation Django 2}


\subsubsection{La syntaxe des gabarits}
\paragraph{Les variables}
Elles utilisent le dictionnaire de contexte pour afficher leur valeur correspondante. Les noms des variables sont les clés du dictionnaire. Dans le gabarit, les variables sont entourées de doubles accolades: \mintinline{python3}{\{\{} et \mintinline{python3}{\}\}}. Par exemple, le gabarit
\begin{minted}{text}
La chanson {{ chanson }} a été écrite par {{ artiste }}.
\end{minted}
avec le dictionnaire \mintinline{python3}{\{'artiste': 'Muse', 'chanson': 'Starlight'\}} donnera:
\begin{minted}{text}
La chanson Starlight a été écrite par Muse.
\end{minted}

On accèdes aux attributs d'instances, aux indices de listes, aux clés de dictionnaires par une notation pointée.
\begin{minted}{text}
{{ dico.clé }}
{{ objet.attribut }}
{{ liste.indice }}
\end{minted}

Si la valeur de la variable est une fonction (ou n'importe quel objet appealble), il sera appelé sans paramètre et le résultat retourné sera utilisé.

\paragraph{Les balises} Elles \marginpar{\href{https://docs.djangoproject.com/fr/2.0/ref/templates/builtins/\#built-in-tag-reference}{Balises intégrées}}permettent de faire diverses choses, comme utiliser des boucles logiques ou insérer d'autres gabarits. Leur nom sont entourés de \mintinline{python3}{\{\%} et \mintinline{python3}{\%\}}. Certaines balises sont orphelines, les autres s'utilisent comme ceci:

\begin{minted}{html}
<!-- Exemple de balise nommée balise. -->
{% balise %}
<!-- Contenu -->
{% endbalise %}
\end{minted}

\begin{description}
	\item[\mintinline{python3}{block}] (oprheline)

	      Définit un bloc pouvant être surchargé par des gabarits enfants.

	\item[\mintinline{python3}{comment}]~

	      Ignore ce qui est compris entre \mintinline{python3}{\{\% comment \%\}} et \mintinline{python3}{\{\% endcomment \%\}}.

	\item[\mintinline{python3}{if}]~

	      Evalue une variable et, si celle-ci vaut \mintinline{python3}{True} (ie est différent de \mintinline{python3}{False}, \mintinline{python3}{''} ou \mintinline{python3}{None}), affiche le bloc correspondant.

	      \begin{minted}{html}
{% if var_1 %}
    <!-- contenu -->
{% elif var_2 > var_3 %}
    <!-- contenu -->
{% elif var_4 and var_5 or var_6 %}
    <!-- OR est prioritaire sur AND.
    Utiliser des parenthèses est une erreur de syntaxe,
    utiliser des IF imbriqués si nécessaire. -->
{% elif var_7 in var_8 %}
    <!-- contenu -->
{% elif var_9 is not var_10 %}
    <!-- contenu -->
{% endif %}
    \end{minted}

	\item[\mintinline{python3}{firstof}] (orpheline)

	      Affiche le premier paramètre qui ne vaut pas \mintinline{python3}{False} et rien dans le cas où aucun paramètre n'est vrai. On peut ajouter un dernier paramètre si aucun n'est validé. On peut utiliser le mot clé \mintinline{python3}{as} pour stocker la variable (voir \mintinline{python3}{cycle} un peu plus bas).

	      \begin{minted}{html}
{% firstof var1 var2 var3 "dernier recours" %}
<!-- est l'équivalent de -->
{% if var1 %}
    {{ var1 }}
{% elif var2 %}
    {{ var2 }}
{% elif var3 %}
    {{ var3 }}
{% else %}
    "dernier recours"
{% endif %}
    \end{minted}

	\item[\mintinline{python3}{for}]~

	      Effectue une boucle sur chaque élément d'une liste. On peut ensuite utiliser cet élément comme variable. Exemple:
	      \begin{minted}{html}
<ul>
{% for artiste in liste_artistes %}
    <li>{{ artiste.nom }}</li>
{% endfor %}
</ul>
    \end{minted}

	      On peut ajouter une balise \mintinline{html}{{% empty %}} pour afficher du contenu lorsque la liste est vide (ou n'existe pas).

	\item[\mintinline{python3}{cycle}] (orpheline)

	      Affiche un de ses paramètres à chaque apparition de la balise: le premier, puis le deuxième, et ainsi de suite; et revient au début lorsque tous les paramètres ont été utilisés. On peut mélanger variables et chaînes de caractères, par exemple:

	      \begin{minted}{html}
{% for elemt in liste %}
    <div class="{% cycle 'chaine_1' variable_de_la_chaine_2 'chaine_3' %}">
        <!-- contenu -->
    </div>
{% endfor %}
    \end{minted}
	      A la première itération, \mintinline{python3}{"chaine\_1"} sera utilisé, puis la chaîne contenu dans \mintinline{python3}{variable\_de\_la\_chaine\_2}, puis \mintinline{python3}{"chaine\_3"}. Il est également possible de sauvegarder temporairement le paramètre dans une variable que l'on peut réutiliser plus loin.

	      \begin{minted}{html}
{% for elemt in liste %}
    <div class="{% cycle 'chaine_1' 'chaine_2' as chaine %}">
        <!-- contenu -->
    </div>
    <div class="{{ chaine }}">
    </div>
{% endfor %}
    \end{minted}

\end{description}

\subsubsection{Utiliser les gabarits dans les vues}


\subsection{Les formulaires}
\paragraph{Plus d'informations} \href{https://docs.djangoproject.com/fr/2.0/topics/forms/}{Documentation Django 2 --- Les formulaires}

\section{WSGI}
Ce module permet de faire tourner Python sur un serveur comme Apache. On voit ici comment déployer une application Flask ou Django avec Apache 2.4 sur un système d'exploitation Debian 9 (Stretch). On considère qu'Apache est connu. Premièrement, installer le module d'Apache pour Python 3:

\begin{minted}{bash}
$ sudo apt install libapache2-mod-wsgi-py3
\end{minted}

\subsection{Déploiement de Flask}
\subsubsection{Hôte virtuel}

Notre application respecte l'arborescence:
\begin{minted}{bash}
app/
|---flaskapp.wsgi
|---FlaskApp/
    |---__init__.py
    ...
\end{minted}

On crée un hôte virtuel pour notre application Flask.

\begin{minted}{bash}
$ cd /etc/apache2/sites-availables
\end{minted}

\begin{minted}{text}
<VirtualHost *:80>
    ServerName domain.com
    ServerAdmin youremail@email.com
    WSGIScriptAlias / /var/www/chemin/votre/app/flaskapp.wsgi

    <Directory /var/www/chemin/votre/app/FlaskApp>
        Require all granted # signifie que toute requête est acceptée
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/FlaskApp-error.log
    LogLevel warn
    CustomLog ${APACHE_LOG_DIR}/FlaskApp-access.log combined
</VirtualHost>
\end{minted}

On peut prendre n'importe quel nom pour les logs.

Voici le contenu de notre fichier WSGI :

\begin{minted}{python3}
#!/usr/bin/python
# on dit à Debian d'utiliser python3

import sys
import logging

logging.basicConfig(stream=sys.stderr)
sys.path.insert(0,"/var/www/chemin/votre/app/")

# en assumant que l'on a app=Flask(__name__)
from FlaskApp import app as application
\end{minted}

Voilà! Normalemnt ça marche :) À tester avec un Hello World.

\section{\texttt{win10toast} --- Notifications Windows 10}
\index{win10toast}
\section{\texttt{splinter} --- Naviguer sur Internet}
\index{splinter}


\section{\texttt{pytaglib} --- Tags de fichiers audio}
Ce module premet l'accès et l'écriture aux métadonnées (tags) de fichiers audio. Ce module utilise \mintinline{text}{taglib}.

\subsection{Installation}
Il faut au préalable posséder le paquet de développement de Python, \mintinline{text}{python3-devel} sur Fedora et le paquet de dévelopmment de tiglab, \mintinline{text}{tiglab-devel} sur Fedora. (Pour Debian, il suffit de remplacer \mintinline{text}{devel} par \mintinline{text}{dev}.)

\subsection{Utilisation}
\begin{minted}{pycon}
>>> import taglib
>>> song = taglib.File("chemin/vers/le/fichier.mp3")
>>> song.tags
{'ARTIST': ['Foo'], 'TITLE': ['Bar']}
>>> song.length # durée en secondes
60
>>> song.tags["ARTIST"] = ["Baz"] # toujours sous forme de liste
>>> del song.tags["TITLE"]
>>> song.save()
>>> song.tags
{'ARTIST': ['Baz']}
\end{minted}

Principaux tags:
\begin{itemize}
	\item \mintinline{text}{TITLE}: Titre du morceau
	\item \mintinline{text}{ARTIST}: Artsite du morceau
	\item \mintinline{text}{ALBUM}: Album
	\item \mintinline{text}{COMPOSER}: Compositeur (utilse pour la musique classique)
	\item \mintinline{text}{TRACKNUMBER}: Numéro de piste
	\item \mintinline{text}{DATE}: Année de sortie
\end{itemize}

\section{\texttt{autopy} --- Tâches automatiques}
\index{autopy}

\part{Conventions des Python Enhancement Proposals}
\section{PEP 8 : Conventions de style du code Python}
\section{PEP 257 : Convention des docstrings}


\printindex
\end{document}
